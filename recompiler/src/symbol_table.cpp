/**
 * @file symbol_table.cpp
 * @brief Symbol table for function and label names
 */

#include <cstdint>
#include <string>
#include <unordered_map>
#include <fstream>
#include <sstream>

namespace gbrecomp {

/**
 * @brief Stores symbol information for addresses
 */
struct Symbol {
    std::string name;
    uint32_t addr;
    enum class Type {
        FUNCTION,
        LABEL,
        DATA,
        UNKNOWN
    } type;
    std::string comment;
};

/**
 * @brief Symbol table for managing named addresses
 */
class SymbolTable {
public:
    /**
     * @brief Add a symbol
     */
    void add_symbol(uint32_t addr, const std::string& name, Symbol::Type type = Symbol::Type::UNKNOWN) {
        symbols_[addr] = {name, addr, type, ""};
        name_to_addr_[name] = addr;
    }
    
    /**
     * @brief Add a symbol with comment
     */
    void add_symbol(uint32_t addr, const std::string& name, Symbol::Type type, const std::string& comment) {
        symbols_[addr] = {name, addr, type, comment};
        name_to_addr_[name] = addr;
    }
    
    /**
     * @brief Get symbol at address
     * @return Pointer to symbol or nullptr
     */
    const Symbol* get_symbol(uint32_t addr) const {
        auto it = symbols_.find(addr);
        return (it != symbols_.end()) ? &it->second : nullptr;
    }
    
    /**
     * @brief Get symbol name or generate one
     */
    std::string get_name(uint32_t addr) const {
        auto it = symbols_.find(addr);
        if (it != symbols_.end()) {
            return it->second.name;
        }
        // Generate name from address
        std::ostringstream ss;
        uint8_t bank = static_cast<uint8_t>(addr >> 16);
        uint16_t offset = static_cast<uint16_t>(addr & 0xFFFF);
        if (bank > 0) {
            ss << "loc_" << std::hex << (int)bank << "_" << offset;
        } else {
            ss << "loc_" << std::hex << offset;
        }
        return ss.str();
    }
    
    /**
     * @brief Look up address by name
     * @return Address or 0xFFFFFFFF if not found
     */
    uint32_t get_address(const std::string& name) const {
        auto it = name_to_addr_.find(name);
        return (it != name_to_addr_.end()) ? it->second : 0xFFFFFFFF;
    }
    
    /**
     * @brief Check if address has a symbol
     */
    bool has_symbol(uint32_t addr) const {
        return symbols_.find(addr) != symbols_.end();
    }
    
    /**
     * @brief Load symbols from a .sym file (no$gmb format)
     */
    bool load_sym_file(const std::string& path) {
        std::ifstream file(path);
        if (!file) return false;
        
        std::string line;
        while (std::getline(file, line)) {
            // Skip empty lines and comments
            if (line.empty() || line[0] == ';') continue;
            
            // Format: bank:addr name
            // Example: 00:0150 Start
            size_t colon = line.find(':');
            size_t space = line.find(' ');
            
            if (colon != std::string::npos && space != std::string::npos && space > colon) {
                try {
                    uint8_t bank = std::stoi(line.substr(0, colon), nullptr, 16);
                    uint16_t offset = std::stoi(line.substr(colon + 1, space - colon - 1), nullptr, 16);
                    std::string name = line.substr(space + 1);
                    
                    // Trim whitespace from name
                    size_t end = name.find_last_not_of(" \t\r\n");
                    if (end != std::string::npos) {
                        name = name.substr(0, end + 1);
                    }
                    
                    uint32_t addr = (static_cast<uint32_t>(bank) << 16) | offset;
                    add_symbol(addr, name);
                } catch (...) {
                    // Skip malformed lines
                }
            }
        }
        
        return true;
    }
    
    /**
     * @brief Save symbols to a .sym file
     */
    bool save_sym_file(const std::string& path) const {
        std::ofstream file(path);
        if (!file) return false;
        
        file << "; Symbol file generated by gbrecomp\n";
        
        for (const auto& [addr, sym] : symbols_) {
            uint8_t bank = static_cast<uint8_t>(addr >> 16);
            uint16_t offset = static_cast<uint16_t>(addr & 0xFFFF);
            
            file << std::hex << std::uppercase
                 << std::setfill('0') << std::setw(2) << (int)bank << ":"
                 << std::setfill('0') << std::setw(4) << offset << " "
                 << sym.name << "\n";
        }
        
        return true;
    }
    
    /**
     * @brief Get all symbols
     */
    const std::unordered_map<uint32_t, Symbol>& symbols() const {
        return symbols_;
    }
    
    /**
     * @brief Clear all symbols
     */
    void clear() {
        symbols_.clear();
        name_to_addr_.clear();
    }
    
    /**
     * @brief Add standard GameBoy symbols
     */
    void add_standard_symbols() {
        // Interrupt vectors
        add_symbol(0x0040, "vblank_handler", Symbol::Type::FUNCTION);
        add_symbol(0x0048, "lcdc_handler", Symbol::Type::FUNCTION);
        add_symbol(0x0050, "timer_handler", Symbol::Type::FUNCTION);
        add_symbol(0x0058, "serial_handler", Symbol::Type::FUNCTION);
        add_symbol(0x0060, "joypad_handler", Symbol::Type::FUNCTION);
        
        // RST vectors
        add_symbol(0x0000, "rst_00", Symbol::Type::FUNCTION);
        add_symbol(0x0008, "rst_08", Symbol::Type::FUNCTION);
        add_symbol(0x0010, "rst_10", Symbol::Type::FUNCTION);
        add_symbol(0x0018, "rst_18", Symbol::Type::FUNCTION);
        add_symbol(0x0020, "rst_20", Symbol::Type::FUNCTION);
        add_symbol(0x0028, "rst_28", Symbol::Type::FUNCTION);
        add_symbol(0x0030, "rst_30", Symbol::Type::FUNCTION);
        add_symbol(0x0038, "rst_38", Symbol::Type::FUNCTION);
        
        // Entry point
        add_symbol(0x0100, "entry", Symbol::Type::FUNCTION);
    }
    
private:
    std::unordered_map<uint32_t, Symbol> symbols_;
    std::unordered_map<std::string, uint32_t> name_to_addr_;
};

} // namespace gbrecomp
