/**
 * @file c_emitter.cpp
 * @brief C code emitter implementation (MVP)
 */

#include "recompiler/codegen/c_emitter.h"
#include <iomanip>
#include <iostream>
#include <fstream>
#include <filesystem>
#include <algorithm>

namespace gbrecomp {
namespace codegen {

/* ============================================================================
 * CEmitter Constructor
 * ========================================================================== */

CEmitter::CEmitter(std::ostream& output, const GeneratorOptions& options)
    : out_(output), options_(options), indent_level_(0) {}

/* ============================================================================
 * Helper Methods
 * ========================================================================== */

void CEmitter::emit_indent() {
    for (int i = 0; i < indent_level_; i++) {
        out_ << "    ";
    }
}

void CEmitter::emit_line(const std::string& line) {
    emit_indent();
    out_ << line << "\n";
}

const char* CEmitter::reg8_name(uint8_t reg) {
    static const char* names[] = {"A", "B", "C", "D", "E", "H", "L", "(HL)"};
    return reg < 8 ? names[reg] : "?";
}

const char* CEmitter::reg16_name(uint8_t reg) {
    static const char* names[] = {"BC", "DE", "HL", "SP", "AF"};
    return reg < 5 ? names[reg] : "?";
}

const char* CEmitter::condition_code(uint8_t cc) {
    static const char* names[] = {"NZ", "Z", "NC", "C"};
    return cc < 4 ? names[cc] : "?";
}

const char* CEmitter::condition_expr(uint8_t cc) {
    switch (cc) {
        case 0: return "!FLAG_Z(ctx)";   // NZ
        case 1: return "FLAG_Z(ctx)";    // Z
        case 2: return "!FLAG_C(ctx)";   // NC
        case 3: return "FLAG_C(ctx)";    // C
        default: return "true";
    }
}

/* ============================================================================
 * Program Structure
 * ========================================================================== */

void CEmitter::begin_program(const std::string& name) {
    out_ << "/* Generated by gbrecomp from " << name << " */\n";
    out_ << "#include \"gbrt.h\"\n\n";
    current_function_ = "";
}

void CEmitter::end_program() {
    out_ << "\n/* End of generated code */\n";
}

void CEmitter::begin_function(const std::string& name, uint8_t bank, uint16_t addr) {
    out_ << "\n/* Function at ";
    if (bank > 0) {
        out_ << std::hex << std::setfill('0') << std::setw(2) << (int)bank << ":";
    }
    out_ << std::hex << std::setfill('0') << std::setw(4) << addr << std::dec << " */\n";
    out_ << "void " << name << "(GBContext* ctx) {\n";
    current_function_ = name;
    indent_level_ = 1;
}

void CEmitter::end_function() {
    indent_level_ = 0;
    out_ << "}\n";
    current_function_ = "";
}

void CEmitter::emit_label(const std::string& label) {
    // Labels are at indent 0, code at indent 1
    out_ << label << ":\n";
}

/* ============================================================================
 * Data Movement
 * ========================================================================== */

void CEmitter::emit_mov_reg_reg(uint8_t dst, uint8_t src) {
    emit_indent();
    out_ << "ctx->" << reg8_name(dst) << " = ctx->" << reg8_name(src) << ";\n";
}

void CEmitter::emit_mov_reg_imm8(uint8_t dst, uint8_t imm) {
    emit_indent();
    out_ << "ctx->" << reg8_name(dst) << " = 0x" << std::hex << std::setfill('0') 
         << std::setw(2) << (int)imm << std::dec << ";\n";
}

void CEmitter::emit_mov_reg16_imm16(uint8_t dst, uint16_t imm) {
    emit_indent();
    out_ << "gbrt_set_" << reg16_name(dst) << "(ctx, 0x" << std::hex << std::setfill('0') 
         << std::setw(4) << imm << std::dec << ");\n";
}

void CEmitter::emit_load8_addr(uint8_t dst, uint16_t addr) {
    emit_indent();
    out_ << "ctx->" << reg8_name(dst) << " = gbrt_read8(ctx, 0x" << std::hex 
         << std::setfill('0') << std::setw(4) << addr << std::dec << ");\n";
}

void CEmitter::emit_load8_reg(uint8_t dst, uint8_t addr_reg) {
    emit_indent();
    out_ << "ctx->" << reg8_name(dst) << " = gbrt_read8(ctx, gbrt_get_" 
         << reg16_name(addr_reg) << "(ctx));\n";
}

void CEmitter::emit_load16_addr(uint8_t dst, uint16_t addr) {
    emit_indent();
    out_ << "gbrt_set_" << reg16_name(dst) << "(ctx, gbrt_read16(ctx, 0x" << std::hex 
         << std::setfill('0') << std::setw(4) << addr << std::dec << "));\n";
}

void CEmitter::emit_store8_addr(uint16_t addr, uint8_t src) {
    emit_indent();
    out_ << "gbrt_write8(ctx, 0x" << std::hex << std::setfill('0') << std::setw(4) 
         << addr << std::dec << ", ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_store8_reg(uint8_t addr_reg, uint8_t src) {
    emit_indent();
    out_ << "gbrt_write8(ctx, gbrt_get_" << reg16_name(addr_reg) << "(ctx), ctx->" 
         << reg8_name(src) << ");\n";
}

void CEmitter::emit_store16_addr(uint16_t addr, uint8_t src) {
    emit_indent();
    out_ << "gbrt_write16(ctx, 0x" << std::hex << std::setfill('0') << std::setw(4) 
         << addr << std::dec << ", gbrt_get_" << reg16_name(src) << "(ctx));\n";
}

void CEmitter::emit_push(uint8_t reg16) {
    emit_indent();
    out_ << "gbrt_push16(ctx, gbrt_get_" << reg16_name(reg16) << "(ctx));\n";
}

void CEmitter::emit_pop(uint8_t reg16) {
    emit_indent();
    out_ << "gbrt_set_" << reg16_name(reg16) << "(ctx, gbrt_pop16(ctx));\n";
}

/* ============================================================================
 * ALU Operations
 * ========================================================================== */

void CEmitter::emit_add_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_add_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_add_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_add_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_adc_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_adc_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_adc_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_adc_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_sub_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_sub_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_sub_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_sub_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_sbc_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_sbc_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_sbc_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_sbc_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_and_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_and_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_and_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_and_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_or_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_or_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_or_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_or_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_xor_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_xor_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_xor_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_xor_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_cp_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_cp_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_cp_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_cp_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_inc_reg8(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_inc8(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_dec_reg8(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_dec8(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_inc_reg16(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_set_" << reg16_name(reg) << "(ctx, gbrt_get_" << reg16_name(reg) 
         << "(ctx) + 1);\n";
}

void CEmitter::emit_dec_reg16(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_set_" << reg16_name(reg) << "(ctx, gbrt_get_" << reg16_name(reg) 
         << "(ctx) - 1);\n";
}

void CEmitter::emit_inc_mem_hl() {
    emit_line("gbrt_inc_mem_hl(ctx);");
}

void CEmitter::emit_dec_mem_hl() {
    emit_line("gbrt_dec_mem_hl(ctx);");
}

void CEmitter::emit_add_hl_reg16(uint8_t src) {
    emit_indent();
    out_ << "gbrt_add_hl(ctx, gbrt_get_" << reg16_name(src) << "(ctx));\n";
}

void CEmitter::emit_add_sp_imm8(int8_t offset) {
    emit_indent();
    out_ << "gbrt_add_sp(ctx, " << (int)offset << ");\n";
}

/* ============================================================================
 * Bit Operations
 * ========================================================================== */

void CEmitter::emit_rlc_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_rlc(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_rrc_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_rrc(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_rl_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_rl(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_rr_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_rr(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_sla_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_sla(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_sra_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_sra(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_srl_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_srl(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_swap_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_swap(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_bit_n_reg(uint8_t bit, uint8_t reg) {
    emit_indent();
    out_ << "gbrt_bit(ctx, " << (int)bit << ", ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_set_n_reg(uint8_t bit, uint8_t reg) {
    emit_indent();
    out_ << "ctx->" << reg8_name(reg) << " |= (1 << " << (int)bit << ");\n";
}

void CEmitter::emit_res_n_reg(uint8_t bit, uint8_t reg) {
    emit_indent();
    out_ << "ctx->" << reg8_name(reg) << " &= ~(1 << " << (int)bit << ");\n";
}

void CEmitter::emit_rlc_hl() { emit_line("gbrt_rlc_hl(ctx);"); }
void CEmitter::emit_rrc_hl() { emit_line("gbrt_rrc_hl(ctx);"); }
void CEmitter::emit_rl_hl() { emit_line("gbrt_rl_hl(ctx);"); }
void CEmitter::emit_rr_hl() { emit_line("gbrt_rr_hl(ctx);"); }
void CEmitter::emit_sla_hl() { emit_line("gbrt_sla_hl(ctx);"); }
void CEmitter::emit_sra_hl() { emit_line("gbrt_sra_hl(ctx);"); }
void CEmitter::emit_srl_hl() { emit_line("gbrt_srl_hl(ctx);"); }
void CEmitter::emit_swap_hl() { emit_line("gbrt_swap_hl(ctx);"); }

void CEmitter::emit_bit_n_hl(uint8_t bit) {
    emit_indent();
    out_ << "gbrt_bit_hl(ctx, " << (int)bit << ");\n";
}

void CEmitter::emit_set_n_hl(uint8_t bit) {
    emit_indent();
    out_ << "gbrt_set_hl(ctx, " << (int)bit << ");\n";
}

void CEmitter::emit_res_n_hl(uint8_t bit) {
    emit_indent();
    out_ << "gbrt_res_hl(ctx, " << (int)bit << ");\n";
}

void CEmitter::emit_rlca() { emit_line("gbrt_rlca(ctx);"); }
void CEmitter::emit_rrca() { emit_line("gbrt_rrca(ctx);"); }
void CEmitter::emit_rla() { emit_line("gbrt_rla(ctx);"); }
void CEmitter::emit_rra() { emit_line("gbrt_rra(ctx);"); }

/* ============================================================================
 * Control Flow
 * ========================================================================== */

void CEmitter::emit_jump(const std::string& label) {
    emit_indent();
    out_ << "goto " << label << ";\n";
}

void CEmitter::emit_jump_cc(uint8_t cc, const std::string& label,
                            const std::string& fallthrough_label) {
    emit_indent();
    out_ << "if (" << condition_expr(cc) << ") goto " << label << ";\n";
    (void)fallthrough_label;  // Not needed with goto
}

void CEmitter::emit_jump_hl() {
    emit_line("gbrt_jump_hl(ctx); return;");
}

void CEmitter::emit_jr(int8_t offset, const std::string& label) {
    (void)offset;  // Using label instead
    emit_indent();
    out_ << "goto " << label << ";\n";
}

void CEmitter::emit_jr_cc(uint8_t cc, int8_t offset, const std::string& label,
                          const std::string& fallthrough_label) {
    (void)offset;
    emit_jump_cc(cc, label, fallthrough_label);
}

void CEmitter::emit_call(const std::string& func_name) {
    emit_indent();
    out_ << func_name << "(ctx);\n";
}

void CEmitter::emit_call_cc(uint8_t cc, const std::string& func_name,
                            const std::string& fallthrough_label) {
    emit_indent();
    out_ << "if (" << condition_expr(cc) << ") " << func_name << "(ctx);\n";
    (void)fallthrough_label;
}

void CEmitter::emit_rst(uint8_t vector) {
    emit_indent();
    out_ << "rst_" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)vector << std::dec << "(ctx);\n";
}

void CEmitter::emit_ret() {
    emit_line("return;");
}

void CEmitter::emit_ret_cc(uint8_t cc, const std::string& fallthrough_label) {
    emit_indent();
    out_ << "if (" << condition_expr(cc) << ") return;\n";
    (void)fallthrough_label;
}

void CEmitter::emit_reti() {
    emit_line("ctx->ime = 1;");
    emit_line("return;");
}

void CEmitter::emit_bank_call(uint8_t target_bank, const std::string& func_name) {
    emit_indent();
    out_ << "gbrt_bank_call(ctx, " << (int)target_bank << ", " << func_name << ");\n";
}

void CEmitter::emit_bank_dispatch(uint16_t addr) {
    emit_indent();
    out_ << "gbrt_bank_dispatch(ctx, 0x" << std::hex << std::setfill('0') 
         << std::setw(4) << addr << std::dec << ");\n";
}

/* ============================================================================
 * Special Instructions
 * ========================================================================== */

void CEmitter::emit_nop() {
    // No-op - can emit nothing or a comment
    if (options_.emit_comments) {
        emit_line("/* NOP */");
    }
}

void CEmitter::emit_halt() { emit_line("gbrt_halt(ctx);"); }
void CEmitter::emit_stop() { emit_line("gbrt_stop(ctx);"); }
void CEmitter::emit_di() { emit_line("ctx->ime = 0;"); }
void CEmitter::emit_ei() { emit_line("ctx->ime_scheduled = 1;"); }
void CEmitter::emit_daa() { emit_line("gbrt_daa(ctx);"); }
void CEmitter::emit_cpl() { emit_line("gbrt_cpl(ctx);"); }
void CEmitter::emit_ccf() { emit_line("gbrt_ccf(ctx);"); }
void CEmitter::emit_scf() { emit_line("gbrt_scf(ctx);"); }

/* ============================================================================
 * I/O
 * ========================================================================== */

void CEmitter::emit_ldh_a_n(uint8_t offset) {
    emit_indent();
    out_ << "ctx->A = gbrt_read8(ctx, 0xFF00 + 0x" << std::hex << std::setfill('0') 
         << std::setw(2) << (int)offset << std::dec << ");\n";
}

void CEmitter::emit_ldh_n_a(uint8_t offset) {
    emit_indent();
    out_ << "gbrt_write8(ctx, 0xFF00 + 0x" << std::hex << std::setfill('0') 
         << std::setw(2) << (int)offset << std::dec << ", ctx->A);\n";
}

void CEmitter::emit_ldh_a_c() {
    emit_line("ctx->A = gbrt_read8(ctx, 0xFF00 + ctx->C);");
}

void CEmitter::emit_ldh_c_a() {
    emit_line("gbrt_write8(ctx, 0xFF00 + ctx->C, ctx->A);");
}

/* ============================================================================
 * Memory with increment/decrement
 * ========================================================================== */

void CEmitter::emit_ldi_a_hl() { emit_line("gbrt_ldi_a_hl(ctx);"); }
void CEmitter::emit_ldd_a_hl() { emit_line("gbrt_ldd_a_hl(ctx);"); }
void CEmitter::emit_ldi_hl_a() { emit_line("gbrt_ldi_hl_a(ctx);"); }
void CEmitter::emit_ldd_hl_a() { emit_line("gbrt_ldd_hl_a(ctx);"); }

/* ============================================================================
 * Debug/Comments
 * ========================================================================== */

void CEmitter::emit_comment(const std::string& comment) {
    if (options_.emit_comments) {
        emit_indent();
        out_ << "/* " << comment << " */\n";
    }
}

void CEmitter::emit_source_location(uint8_t bank, uint16_t addr) {
    if (options_.emit_address_comments) {
        emit_indent();
        out_ << "/* ";
        if (bank > 0) {
            out_ << std::hex << std::setfill('0') << std::setw(2) << (int)bank << ":";
        }
        out_ << std::hex << std::setfill('0') << std::setw(4) << addr << std::dec << " */\n";
    }
}

/* ============================================================================
 * Cycle Counting
 * ========================================================================== */

void CEmitter::emit_add_cycles(uint8_t cycles) {
    if (options_.emit_cycle_counting) {
        emit_indent();
        out_ << "ctx->cycles += " << (int)cycles << ";\n";
    }
}

void CEmitter::emit_yield_check() {
    emit_line("if (ctx->cycles >= ctx->cycle_limit) return;");
}

/* ============================================================================
 * Output Generation Functions
 * ========================================================================== */

static const char* reg8_names[] = {"b", "c", "d", "e", "h", "l", nullptr, "a"};
static const char* reg16_names[] = {"bc", "de", "hl", "sp", "af"};
static const char* cond_names[] = {"NZ", "Z", "NC", "C"};

static const char* get_reg8_name(int idx) {
    if (idx < 0 || idx > 7 || idx == 6) return nullptr;
    return reg8_names[idx];
}

static void emit_ir_instruction(std::ostream& out, const ir::IRInstruction& instr, 
                                const ir::Program& program, int indent, 
                                const GeneratorOptions& options,
                                const std::string& current_func_name = "") {
    auto emit_indent = [&out, indent]() {
        for (int i = 0; i < indent; i++) out << "    ";
    };
    
    // Emit source location comment if enabled
    if (options.emit_address_comments && instr.source_address != 0) {
        emit_indent();
        out << "/* " << std::hex << std::setfill('0');
        if (instr.source_bank > 0) {
            out << std::setw(2) << (int)instr.source_bank << ":";
        }
        out << std::setw(4) << instr.source_address << std::dec << " */ ";
    }
    
    // Comment (usually disassembly)
    if (!instr.comment.empty() && options.emit_comments) {
        emit_indent();
        out << "/* " << instr.comment << " */\n";
        return;  // Comment-only instruction
    }
    
    emit_indent();
    
    switch (instr.opcode) {
        case ir::Opcode::NOP:
            out << "/* NOP */\n";
            break;
            
        case ir::Opcode::MOV_REG_REG:
            out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                << " = ctx->" << reg8_names[instr.src.value.reg8] << ";\n";
            break;
            
        case ir::Opcode::MOV_REG_IMM8:
            out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                << " = 0x" << std::hex << std::setfill('0') << std::setw(2) 
                << (int)instr.src.value.imm8 << std::dec << ";\n";
            break;
            
        case ir::Opcode::MOV_REG_IMM16:
            out << "ctx->" << reg16_names[instr.dst.value.reg16] 
                << " = 0x" << std::hex << std::setfill('0') << std::setw(4) 
                << instr.src.value.imm16 << std::dec << ";\n";
            break;
            
        case ir::Opcode::LOAD8: {
            const char* dst_name = get_reg8_name(instr.dst.value.reg8);
            if (!dst_name) dst_name = "a";
            
            if (instr.src.type == ir::OperandType::IMM16) {
                out << "ctx->" << dst_name << " = gb_read8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(4) << instr.src.value.imm16 << std::dec << ");\n";
            } else if (instr.src.type == ir::OperandType::REG16) {
                out << "ctx->" << dst_name << " = gb_read8(ctx, ctx->" 
                    << reg16_names[instr.src.value.reg16] << ");\n";
            } else if (instr.src.type == ir::OperandType::REG8) {
                // LDH A,(C) - 0xFF00 + C
                out << "ctx->" << dst_name << " = gb_read8(ctx, 0xFF00 + ctx->c);\n";
            } else {
                out << "ctx->a = gb_read8(ctx, ctx->hl);\n";
            }
            break;
        }
            
        case ir::Opcode::STORE8:
            if (instr.dst.type == ir::OperandType::IMM16) {
                const char* src_name = get_reg8_name(instr.src.value.reg8);
                if (src_name) {
                    out << "gb_write8(ctx, 0x" << std::hex << std::setfill('0') 
                        << std::setw(4) << instr.dst.value.imm16 << std::dec 
                        << ", ctx->" << src_name << ");\n";
                } else if (instr.src.type == ir::OperandType::IMM8) {
                    out << "gb_write8(ctx, 0x" << std::hex << std::setfill('0') 
                        << std::setw(4) << instr.dst.value.imm16 << std::dec 
                        << ", 0x" << std::setw(2) << (int)instr.src.value.imm8 << ");\n";
                } else {
                    out << "gb_write8(ctx, 0x" << std::hex << std::setfill('0') 
                        << std::setw(4) << instr.dst.value.imm16 << std::dec 
                        << ", ctx->a);\n";
                }
            } else if (instr.dst.type == ir::OperandType::REG16) {
                const char* src_name = get_reg8_name(instr.src.value.reg8);
                if (src_name) {
                    out << "gb_write8(ctx, ctx->" << reg16_names[instr.dst.value.reg16] 
                        << ", ctx->" << src_name << ");\n";
                } else if (instr.src.type == ir::OperandType::IMM8) {
                    out << "gb_write8(ctx, ctx->" << reg16_names[instr.dst.value.reg16] 
                        << ", 0x" << std::hex << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
                } else {
                    out << "gb_write8(ctx, ctx->" << reg16_names[instr.dst.value.reg16] 
                        << ", ctx->a);\n";
                }
            }
            break;
            
        case ir::Opcode::ADD8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_add8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_add8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::ADC8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_adc8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_adc8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::SUB8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_sub8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_sub8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::SBC8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_sbc8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_sbc8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::AND8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_and8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_and8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::OR8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_or8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_or8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::XOR8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_xor8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_xor8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::CP8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_cp8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_cp8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::INC8:
            if (instr.dst.value.reg8 == 6) {
                // INC (HL) - read-modify-write memory at address HL
                out << "gb_write8(ctx, ctx->hl, gb_inc8(ctx, gb_read8(ctx, ctx->hl)));\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " = gb_inc8(ctx, ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::DEC8:
            if (instr.dst.value.reg8 == 6) {
                // DEC (HL) - read-modify-write memory at address HL
                out << "gb_write8(ctx, ctx->hl, gb_dec8(ctx, gb_read8(ctx, ctx->hl)));\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " = gb_dec8(ctx, ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::INC16:
            out << "ctx->" << reg16_names[instr.dst.value.reg16] << "++;\n";
            break;
            
        case ir::Opcode::DEC16:
            out << "ctx->" << reg16_names[instr.dst.value.reg16] << "--;\n";
            break;
            
        case ir::Opcode::ADD16:
            out << "gb_add16(ctx, ctx->" << reg16_names[instr.src.value.reg16] << ");\n";
            break;
            
        case ir::Opcode::ADD_SP_IMM8:
            out << "gb_add_sp(ctx, " << (int)instr.src.value.offset << ");\n";
            break;
            
        case ir::Opcode::PUSH16:
            if (instr.dst.value.reg16 == 4) { // AF
                out << "gb_pack_flags(ctx); gb_push16(ctx, ctx->af & 0xFFF0);\n";
            } else {
                out << "gb_push16(ctx, ctx->" << reg16_names[instr.dst.value.reg16] << ");\n";
            }
            break;
            
        case ir::Opcode::POP16:
            if (instr.dst.value.reg16 == 4) { // AF
                out << "ctx->af = gb_pop16(ctx) & 0xFFF0; gb_unpack_flags(ctx);\n";
            } else {
                out << "ctx->" << reg16_names[instr.dst.value.reg16] << " = gb_pop16(ctx);\n";
            }
            break;
            
        case ir::Opcode::JUMP:
            if (instr.dst.type == ir::OperandType::IMM16) {
                uint16_t target = instr.dst.value.imm16;
                uint8_t source_bank = instr.source_bank;
                
                // Check if this is a cross-bank jump
                bool is_cross_bank = false;
                
                // From bank 0 (0x0000-0x3FFF): only cross-bank if target is in 0x4000-0x7FFF
                // From any banked code (0x4000-0x7FFF in bank N): 
                //   - Jumping to 0x0000-0x3FFF is cross-bank (to bank 0)
                //   - Jumping to 0x4000-0x7FFF could be same bank or different bank
                
                if (target >= 0x4000 && target <= 0x7FFF) {
                    // Target is in switchable area - always use dispatch
                    is_cross_bank = true;
                } else if (target < 0x4000 && source_bank > 0) {
                    // Target is in bank 0 fixed area, but we're in a banked function
                    // This is a cross-bank jump to bank 0
                    is_cross_bank = true;
                } else if (target >= 0x8000) {
                    // Target is in RAM/VRAM/etc - not valid code, use dispatch which will handle it
                    is_cross_bank = true;
                }
                
                if (is_cross_bank) {
                    if (options.emit_cycle_counting && instr.cycles > 0) {
                        out << "gb_tick(ctx, " << (int)instr.cycles << ");\n";
                        emit_indent();
                    }
                    out << "gb_dispatch(ctx, 0x" << std::hex << std::setfill('0') 
                        << std::setw(4) << target << std::dec << "); return;\n";
                } else {
                    // Same-bank jump - check if target is a function entry
                    std::ostringstream func_name_ss;
                    func_name_ss << "func_" << std::hex << std::setfill('0') << std::setw(4) << target;
                    std::string func_name = func_name_ss.str();
                    
                    if (program.functions.find(func_name) != program.functions.end()) {
                        // Check if target is the CURRENT function - if so, use goto to avoid recursion
                        if (func_name == current_func_name) {
                            // Cycle tick before goto
                            if (options.emit_cycle_counting && instr.cycles > 0) {
                                out << "gb_tick(ctx, " << (int)instr.cycles << ");\n";
                                emit_indent();
                                out << "if (ctx->stopped) return;\n";
                                emit_indent();
                            }
                            out << "goto loc_" << std::hex << std::setfill('0') 
                                << std::setw(4) << target << std::dec << ";\n";
                        } else {
                            // Target is a different function entry - call it and return
                            if (options.emit_cycle_counting && instr.cycles > 0) {
                                out << "gb_tick(ctx, " << (int)instr.cycles << ");\n";
                                emit_indent();
                            }
                            out << func_name << "(ctx); return;\n";
                        }
                    } else {
                        // Target is a label within a function - emit cycles before goto
                        if (options.emit_cycle_counting && instr.cycles > 0) {
                            out << "gb_tick(ctx, " << (int)instr.cycles << ");\n";
                            emit_indent();
                            out << "if (ctx->stopped) return;\n";
                            emit_indent();
                        }
                        out << "goto loc_" << std::hex << std::setfill('0') 
                            << std::setw(4) << target << std::dec << ";\n";
                    }
                }
            } else if (instr.dst.type == ir::OperandType::REG16) {
                // Indirect jump via register (JP HL)
                if (options.emit_cycle_counting && instr.cycles > 0) {
                    out << "gb_tick(ctx, " << (int)instr.cycles << ");\n";
                    emit_indent();
                }
                out << "gb_dispatch(ctx, ctx->" << reg16_names[instr.dst.value.reg16] << "); return;\n";
            } else {
                if (options.emit_cycle_counting && instr.cycles > 0) {
                    out << "gb_tick(ctx, " << (int)instr.cycles << ");\n";
                    emit_indent();
                }
                out << "gb_dispatch(ctx, ctx->hl); return;\n";
            }
            break;
            
        case ir::Opcode::JUMP_CC: {
            uint16_t target = instr.dst.value.imm16;
            uint8_t source_bank = instr.source_bank;
            const char* cond = cond_names[instr.src.value.condition];
            const char* expr = (instr.src.value.condition == 0) ? "!ctx->f_z" :
                               (instr.src.value.condition == 1) ? "ctx->f_z" :
                               (instr.src.value.condition == 2) ? "!ctx->f_c" : "ctx->f_c";
            
            // Check if this is a cross-bank jump
            bool is_cross_bank = false;
            if (target >= 0x4000 && target <= 0x7FFF && source_bank == 0) {
                // Jump from bank 0 to switchable bank region - cross-bank
                is_cross_bank = true;
            } else if (target < 0x4000 && source_bank > 0) {
                // Jump from switchable bank to bank 0 - cross-bank
                is_cross_bank = true;
            } else if (target >= 0x8000) {
                // Target is in RAM/VRAM/etc - not valid code
                is_cross_bank = true;
            }
            
            if (is_cross_bank) {
                out << "if (" << expr << ") { gb_dispatch(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(4) << target << std::dec << "); return; } /* " << cond << " */\n";
            } else {
                // Check if target is a function entry
                std::ostringstream func_name_ss;
                if (source_bank > 0) {
                    func_name_ss << "func_" << std::hex << std::setfill('0') << std::setw(2) << (int)source_bank << "_" << std::setw(4) << target;
                } else {
                    func_name_ss << "func_" << std::hex << std::setfill('0') << std::setw(4) << target;
                }
                std::string func_name = func_name_ss.str();
                
                if (program.functions.find(func_name) != program.functions.end()) {
                    // Check if target is the CURRENT function - if so, use goto to avoid recursion
                    if (func_name == current_func_name) {
                        out << "if (" << expr << ") goto loc_" << std::hex << std::setfill('0') 
                            << std::setw(4) << target << std::dec << "; /* " << cond << " */\n";
                    } else {
                        // Target is a different function entry - call it and return on condition
                        out << "if (" << expr << ") { " << func_name << "(ctx); return; } /* " << cond << " */\n";
                    }
                } else {
                    out << "if (" << expr << ") goto loc_" << std::hex << std::setfill('0') 
                        << std::setw(4) << target << std::dec << "; /* " << cond << " */\n";
                }
            }
            break;
        }
            
        case ir::Opcode::CALL: {
            uint16_t target = instr.dst.value.imm16;
            
            // For targets in banked area (0x4000-0x7FFF), always use dispatch since
            // we don't know which bank will be active at runtime
            if (target >= 0x4000 && target <= 0x7FFF) {
                out << "gb_dispatch_call(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(4) << target << std::dec << ");\n";
            } else {
                // For bank 0 targets, try direct call
                std::ostringstream func_name_ss;
                func_name_ss << "func_" << std::hex << std::setfill('0') << std::setw(4) << target;
                std::string func_name = func_name_ss.str();
                
                // Check if function exists in analyzed program
                if (program.functions.find(func_name) != program.functions.end()) {
                    out << func_name << "(ctx);\n";
                } else {
                    // Fallback to runtime dispatch for unknown targets (e.g., HRAM code)
                    out << "gb_dispatch_call(ctx, 0x" << std::hex << std::setfill('0') 
                        << std::setw(4) << target << std::dec << ");\n";
                }
            }
            break;
        }
            
        case ir::Opcode::CALL_CC: {
            uint16_t target = instr.dst.value.imm16;
            
            const char* cond = cond_names[instr.src.value.condition];
            const char* expr = (instr.src.value.condition == 0) ? "!ctx->f_z" :
                               (instr.src.value.condition == 1) ? "ctx->f_z" :
                               (instr.src.value.condition == 2) ? "!ctx->f_c" : "ctx->f_c";
            
            // For targets in banked area (0x4000-0x7FFF), always use dispatch
            if (target >= 0x4000 && target <= 0x7FFF) {
                out << "if (" << expr << ") gb_dispatch_call(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(4) << target << std::dec << "); /* " << cond << " */\n";
            } else {
                std::ostringstream func_name_ss;
                func_name_ss << "func_" << std::hex << std::setfill('0') << std::setw(4) << target;
                std::string func_name = func_name_ss.str();
                
                // Check if function exists in analyzed program
                if (program.functions.find(func_name) != program.functions.end()) {
                    out << "if (" << expr << ") " << func_name << "(ctx); /* " << cond << " */\n";
                } else {
                    out << "if (" << expr << ") gb_dispatch_call(ctx, 0x" << std::hex << std::setfill('0') 
                        << std::setw(4) << target << std::dec << "); /* " << cond << " */\n";
                }
            }
            break;
        }
            
        case ir::Opcode::RET:
            if (options.emit_cycle_counting && instr.cycles > 0) {
                out << "gb_tick(ctx, " << (int)instr.cycles << ");\n";
                emit_indent();
            }
            out << "return;\n";
            break;
            
        case ir::Opcode::RET_CC: {
            const char* cond = cond_names[instr.src.value.condition];
            const char* expr = (instr.src.value.condition == 0) ? "!ctx->f_z" :
                               (instr.src.value.condition == 1) ? "ctx->f_z" :
                               (instr.src.value.condition == 2) ? "!ctx->f_c" : "ctx->f_c";
            out << "if (" << expr << ") return; /* " << cond << " */\n";
            break;
        }
            
        case ir::Opcode::RETI:
            if (options.emit_cycle_counting && instr.cycles > 0) {
                out << "gb_tick(ctx, " << (int)instr.cycles << ");\n";
                emit_indent();
            }
            out << "ctx->ime = 1; return;\n";
            break;
            
        case ir::Opcode::RST:
            // For RST 28 (Jump Table), we must emulate the PUSH PC behavior because
            // the handler normally pops the return address to use as a data pointer.
            if (instr.dst.value.rst_vec == 0x28) {
                uint16_t next_pc = instr.source_address + 1;
                out << "gb_push16(ctx, 0x" << std::hex << next_pc << std::dec << ");\n";
                emit_indent();
            }
            out << "rst_" << std::hex << std::setfill('0') << std::setw(2) 
                << (int)instr.dst.value.rst_vec << std::dec << "(ctx);\n";
            break;
            
        case ir::Opcode::HALT:
            out << "gb_halt(ctx);\n";
            emit_indent();
            out << "if (ctx->halted) return;\n";
            break;
            
        case ir::Opcode::STOP:
            out << "gb_stop(ctx);\n";
            break;
            
        case ir::Opcode::DI:
            out << "ctx->ime = 0;\n";
            break;
            
        case ir::Opcode::EI:
            out << "ctx->ime_pending = 1;\n";
            break;
            
        case ir::Opcode::DAA:
            out << "gb_daa(ctx);\n";
            break;
            
        case ir::Opcode::CPL:
            out << "ctx->a = ~ctx->a; ctx->f_n = 1; ctx->f_h = 1;\n";
            break;
            
        case ir::Opcode::SCF:
            out << "ctx->f_n = 0; ctx->f_h = 0; ctx->f_c = 1;\n";
            break;
            
        case ir::Opcode::CCF:
            out << "ctx->f_n = 0; ctx->f_h = 0; ctx->f_c = !ctx->f_c;\n";
            break;
            
        case ir::Opcode::BIT:
            if (instr.dst.value.reg8 == 6) {
                // BIT n,(HL) - read from memory
                out << "gb_bit(ctx, " << (int)instr.src.value.bit_idx 
                    << ", gb_read8(ctx, ctx->hl));\n";
            } else {
                out << "gb_bit(ctx, " << (int)instr.src.value.bit_idx 
                    << ", ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::SET:
            if (instr.dst.value.reg8 == 6) {
                // SET n,(HL) - read-modify-write memory
                out << "gb_write8(ctx, ctx->hl, gb_read8(ctx, ctx->hl) | (1 << " 
                    << (int)instr.src.value.bit_idx << "));\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " |= (1 << " << (int)instr.src.value.bit_idx << ");\n";
            }
            break;
            
        case ir::Opcode::RES:
            if (instr.dst.value.reg8 == 6) {
                // RES n,(HL) - read-modify-write memory
                out << "gb_write8(ctx, ctx->hl, gb_read8(ctx, ctx->hl) & ~(1 << " 
                    << (int)instr.src.value.bit_idx << "));\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " &= ~(1 << " << (int)instr.src.value.bit_idx << ");\n";
            }
            break;
        
        // === I/O Port Operations ===
        case ir::Opcode::IO_READ:
            // LDH A,(n) - read from 0xFF00 + immediate offset
            out << "ctx->a = gb_read8(ctx, 0xFF00 + 0x" << std::hex << std::setfill('0') 
                << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            break;
            
        case ir::Opcode::IO_READ_C:
            // LDH A,(C) - read from 0xFF00 + C register
            out << "ctx->a = gb_read8(ctx, 0xFF00 + ctx->c);\n";
            break;
            
        case ir::Opcode::IO_WRITE:
            // LDH (n),A - write to 0xFF00 + immediate offset
            out << "gb_write8(ctx, 0xFF00 + 0x" << std::hex << std::setfill('0') 
                << std::setw(2) << (int)instr.dst.value.imm8 << std::dec << ", ctx->a);\n";
            break;
            
        case ir::Opcode::IO_WRITE_C:
            // LDH (C),A - write to 0xFF00 + C register
            out << "gb_write8(ctx, 0xFF00 + ctx->c, ctx->a);\n";
            break;
            
        // === Rotate/Shift Operations ===
        case ir::Opcode::RLC:
            if (instr.dst.value.reg8 == 6) {
                // RLC (HL) - read, rotate, write back
                out << "gb_write8(ctx, ctx->hl, gb_rlc(ctx, gb_read8(ctx, ctx->hl)));\n";
            } else if (instr.extra.type == ir::OperandType::IMM8 && instr.extra.value.imm8 == 1) {
                // RLCA variant (Z flag always 0)
                out << "gb_rlca(ctx);\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " = gb_rlc(ctx, ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::RRC:
            if (instr.dst.value.reg8 == 6) {
                out << "gb_write8(ctx, ctx->hl, gb_rrc(ctx, gb_read8(ctx, ctx->hl)));\n";
            } else if (instr.extra.type == ir::OperandType::IMM8 && instr.extra.value.imm8 == 1) {
                out << "gb_rrca(ctx);\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " = gb_rrc(ctx, ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::RL:
            if (instr.dst.value.reg8 == 6) {
                out << "gb_write8(ctx, ctx->hl, gb_rl(ctx, gb_read8(ctx, ctx->hl)));\n";
            } else if (instr.extra.type == ir::OperandType::IMM8 && instr.extra.value.imm8 == 1) {
                out << "gb_rla(ctx);\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " = gb_rl(ctx, ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::RR:
            if (instr.dst.value.reg8 == 6) {
                out << "gb_write8(ctx, ctx->hl, gb_rr(ctx, gb_read8(ctx, ctx->hl)));\n";
            } else if (instr.extra.type == ir::OperandType::IMM8 && instr.extra.value.imm8 == 1) {
                out << "gb_rra(ctx);\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " = gb_rr(ctx, ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::SLA:
            if (instr.dst.value.reg8 == 6) {
                out << "gb_write8(ctx, ctx->hl, gb_sla(ctx, gb_read8(ctx, ctx->hl)));\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " = gb_sla(ctx, ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::SRA:
            if (instr.dst.value.reg8 == 6) {
                out << "gb_write8(ctx, ctx->hl, gb_sra(ctx, gb_read8(ctx, ctx->hl)));\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " = gb_sra(ctx, ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::SRL:
            if (instr.dst.value.reg8 == 6) {
                out << "gb_write8(ctx, ctx->hl, gb_srl(ctx, gb_read8(ctx, ctx->hl)));\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " = gb_srl(ctx, ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::SWAP:
            if (instr.dst.value.reg8 == 6) {
                out << "gb_write8(ctx, ctx->hl, gb_swap(ctx, gb_read8(ctx, ctx->hl)));\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " = gb_swap(ctx, ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::MOV_REG_REG16:
            // LD SP,HL - copy 16-bit register to 16-bit register
            out << "ctx->" << reg16_names[instr.dst.value.reg16] 
                << " = ctx->" << reg16_names[instr.src.value.reg16] << ";\n";
            break;
            
        case ir::Opcode::LD_HL_SP_N: {
            // LD HL,SP+n - add signed offset to SP, store in HL, set H/C flags based on low byte
            int8_t offset = instr.src.value.offset;
            out << "{ uint32_t result = ctx->sp + (" << (int)offset << ");\n";
            emit_indent();
            out << "ctx->f_z = 0; ctx->f_n = 0;\n";
            emit_indent();
            out << "ctx->f_h = ((ctx->sp & 0x0F) + (" << (offset & 0x0F) << ")) > 0x0F;\n";
            emit_indent();
            out << "ctx->f_c = ((ctx->sp & 0xFF) + (" << (offset & 0xFF) << ")) > 0xFF;\n";
            emit_indent();
            out << "ctx->hl = (uint16_t)result; }\n";
            break;
        }
            
        case ir::Opcode::STORE16:
            // LD (nn),SP - store 16-bit register to memory
            out << "gb_write16(ctx, 0x" << std::hex << std::setfill('0') 
                << std::setw(4) << instr.dst.value.imm16 << std::dec 
                << ", ctx->" << reg16_names[instr.src.value.reg16] << ");\n";
            break;
            
        default:
            out << "/* Unhandled opcode */\n";
            break;
    }
    
    // Emit cycle counting and PPU tick (but not after control flow statements that already returned)
    bool is_control_flow = (instr.opcode == ir::Opcode::RET || 
                            instr.opcode == ir::Opcode::RETI ||
                            instr.opcode == ir::Opcode::JUMP ||
                            instr.opcode == ir::Opcode::JUMP_REG);
    if (options.emit_cycle_counting && instr.cycles > 0 && !is_control_flow) {
        emit_indent();
        out << "gb_tick(ctx, " << (int)instr.cycles << ");\n";
        emit_indent();
        out << "if (ctx->stopped) return;\n";
    }
}

GeneratedOutput generate_output(const ir::Program& program,
                                const uint8_t* rom_data,
                                size_t rom_size,
                                const GeneratorOptions& options) {
    GeneratedOutput output;
    
    // Generate header
    std::ostringstream header_ss;
    header_ss << "/* Generated by gbrecomp */\n";
    header_ss << "#ifndef " << options.output_prefix << "_H\n";
    header_ss << "#define " << options.output_prefix << "_H\n\n";
    header_ss << "#include \"gbrt.h\"\n\n";
    header_ss << "void " << options.output_prefix << "_run(GBContext* ctx);\n";
    header_ss << "void " << options.output_prefix << "_init(GBContext* ctx);\n\n";
    header_ss << "#endif\n";
    output.header_content = header_ss.str();
    output.header_file = options.output_prefix + ".h";
    
    // Generate source
    std::ostringstream source_ss;
    source_ss << "/* Generated by gbrecomp from " << program.rom_name << " */\n";
    source_ss << "#include \"" << options.output_prefix << ".h\"\n";
    source_ss << "#include \"gbrt.h\"\n\n";
    
    // Forward declarations
    source_ss << "/* Forward declarations */\n";
    for (const auto& [name, func] : program.functions) {
        source_ss << "static void " << func.name << "(GBContext* ctx);\n";
    }
    source_ss << "\n";
    
    // Generate dispatch function for banked calls
    source_ss << "/* Bank dispatch - routes calls to the correct bank function */\n";
    source_ss << "void gb_dispatch(GBContext* ctx, uint16_t addr) {\n";
    source_ss << "    uint8_t bank = ctx->rom_bank;\n";
    source_ss << "    if (addr < 0x4000) bank = 0;\n";
    source_ss << "    switch (addr) {\n";
    
    // Group functions by address for the switch statement
    std::map<uint16_t, std::vector<std::pair<uint8_t, std::string>>> addr_to_funcs;
    for (const auto& [name, func] : program.functions) {
        addr_to_funcs[func.entry_address].push_back({func.bank, func.name});
    }
    
    for (const auto& [addr, funcs] : addr_to_funcs) {
        source_ss << "        case 0x" << std::hex << std::setfill('0') << std::setw(4) << addr << std::dec << ":\n";
        if (funcs.size() == 1) {
            source_ss << "            " << funcs[0].second << "(ctx); return;\n";
        } else {
            // Multiple banks have code at this address
            source_ss << "            switch (bank) {\n";
            for (const auto& [bank, func_name] : funcs) {
                source_ss << "                case " << (int)bank << ": " << func_name << "(ctx); return;\n";
            }
            source_ss << "                default: gb_interpret(ctx, addr); return;\n";
            source_ss << "            }\n";
        }
    }
    source_ss << "        default: gb_interpret(ctx, addr); return;\n";
    source_ss << "    }\n";
    source_ss << "}\n\n";
    
    source_ss << "void gb_dispatch_call(GBContext* ctx, uint16_t addr) {\n";
    source_ss << "    gb_dispatch(ctx, addr);\n";
    source_ss << "}\n\n";
    
    // Emit each function with real IR code
    for (const auto& [name, func] : program.functions) {
        source_ss << "/* Function at ";
        if (func.bank > 0) {
            source_ss << std::hex << std::setfill('0') << std::setw(2) << (int)func.bank << ":";
        }
        source_ss << std::hex << std::setfill('0') << std::setw(4) << func.entry_address << std::dec << " */\n";
        source_ss << "static void " << func.name << "(GBContext* ctx) {\n";
        
        // Sort block_ids by their start address to ensure proper fallthrough order
        std::vector<uint32_t> sorted_block_ids = func.block_ids;
        std::sort(sorted_block_ids.begin(), sorted_block_ids.end(), 
            [&program](uint32_t a, uint32_t b) {
                auto it_a = program.blocks.find(a);
                auto it_b = program.blocks.find(b);
                if (it_a == program.blocks.end()) return false;
                if (it_b == program.blocks.end()) return true;
                return it_a->second.start_address < it_b->second.start_address;
            });
        
        // Emit each block in this function (now sorted by address)
        for (size_t block_idx = 0; block_idx < sorted_block_ids.size(); block_idx++) {
            uint32_t block_id = sorted_block_ids[block_idx];
            auto block_it = program.blocks.find(block_id);
            if (block_it == program.blocks.end()) continue;
            const ir::BasicBlock& block = block_it->second;
            
            // Generate label from block address
            source_ss << "loc_" << std::hex << std::setfill('0') << std::setw(4) 
                      << block.start_address << std::dec << ":\n";
            
            // Emit each IR instruction
            for (const auto& ir_instr : block.instructions) {
                emit_ir_instruction(source_ss, ir_instr, program, 1, options, func.name);
            }
            
            // Check if block falls through
            bool falls_through = true;
            uint16_t fallthrough_addr = block.end_address;
            
            // Find the last non-NOP instruction
            for (auto it = block.instructions.rbegin(); it != block.instructions.rend(); ++it) {
                if (it->opcode == ir::Opcode::NOP) continue;
                
                // Unconditional terminators do not fall through
                if (it->opcode == ir::Opcode::JUMP || 
                    it->opcode == ir::Opcode::RET) {
                    falls_through = false;
                }
                break;
            }
            
            bool next_is_fallthrough = false;
            if (block_idx + 1 < sorted_block_ids.size()) {
                uint32_t next_id = sorted_block_ids[block_idx + 1];
                auto next_it = program.blocks.find(next_id);
                if (next_it != program.blocks.end()) {
                    if (next_it->second.start_address == fallthrough_addr) {
                        next_is_fallthrough = true;
                    }
                }
            }
            
            if (falls_through && !next_is_fallthrough) {
                    // Debug specific function 27eb
                    if (func.name == "func_27eb") {
                        std::cerr << "DEBUG: found func_27eb falling through to 0x" << std::hex << fallthrough_addr << std::dec << "\n";
                    }

                    // Check if fallthrough target exists as a block in this function
                    bool fallthrough_exists_in_function = false;
                    for (uint32_t fn_block_id : sorted_block_ids) {
                        auto fn_block_it = program.blocks.find(fn_block_id);
                        if (fn_block_it != program.blocks.end() && 
                            fn_block_it->second.start_address == fallthrough_addr) {
                            fallthrough_exists_in_function = true;
                            break;
                        }
                    }
                    
                    // Only emit goto if the target block exists in this function
                    if (fallthrough_exists_in_function) {
                        // Emit explicit goto to fallthrough block
                        source_ss << "    goto loc_" << std::hex << std::setfill('0') 
                                  << std::setw(4) << fallthrough_addr << std::dec 
                                  << "; /* fallthrough */\n";
                    } else {
                        if (func.name == "func_27eb") {
                             std::cerr << "DEBUG: func_27eb fallthrough not in function. Searching targets...\n";
                        }
                        // Fallthrough to another function?
                        // Check if any function starts at fallthrough_addr in the same bank
                        bool found_target_func = false;
                        for (const auto& kv : program.functions) {
                            const ir::Function& target_func = kv.second;
                            if (target_func.bank == func.bank && target_func.entry_address == fallthrough_addr) {
                                source_ss << "    /* fallthrough to function */\n";
                                source_ss << "    " << target_func.name << "(ctx);\n";
                                source_ss << "    return;\n";
                                found_target_func = true;
                                if (func.name == "func_27eb") std::cerr << "DEBUG: Found target: " << target_func.name << "\n";
                                break;
                            }
                        }
                        
                        if (!found_target_func) {
                            if (func.name == "func_27eb") std::cerr << "DEBUG: No target function found for 0x" << std::hex << fallthrough_addr << std::dec << "\n";
                            source_ss << "    /* warning: fallthrough to unanalyzed code at 0x" 
                                      << std::hex << fallthrough_addr << std::dec << " in bank " << (int)func.bank << " */\n";
                            
                            source_ss << "    return;\n";
                        }
                    }

            }
        }
        
        // If function is empty or has no terminator, add a return
        source_ss << "}\n\n";
    }
    
    // Extern reference to ROM data
    source_ss << "/* Extern reference to ROM data */\n";
    source_ss << "extern const uint8_t rom_data[];\n\n";
    
    // Emit init and run functions
    source_ss << "void " << options.output_prefix << "_init(GBContext* ctx) {\n";
    source_ss << "    /* Load ROM data into context */\n";
    source_ss << "    gb_context_load_rom(ctx, rom_data, " << rom_size << ");\n";
    source_ss << "}\n\n";
    
    source_ss << "void " << options.output_prefix << "_run(GBContext* ctx) {\n";
    source_ss << "    gb_main(ctx);\n";  // Call the game's main function
    source_ss << "}\n";
    
    output.source_content = source_ss.str();
    output.source_file = options.output_prefix + ".c";
    
    // Generate ROM data
    std::ostringstream rom_ss;
    rom_ss << "/* ROM data */\n";
    rom_ss << "#include <stdint.h>\n";
    rom_ss << "#include <stddef.h>\n\n";
    rom_ss << "const uint8_t rom_data[" << rom_size << "] = {\n";
    for (size_t i = 0; i < rom_size; i++) {
        if (i % 16 == 0) rom_ss << "    ";
        rom_ss << "0x" << std::hex << std::setfill('0') << std::setw(2) 
               << (int)rom_data[i];
        if (i < rom_size - 1) rom_ss << ",";
        if (i % 16 == 15 || i == rom_size - 1) rom_ss << "\n";
        else rom_ss << " ";
    }
    rom_ss << std::dec << "};\n";
    rom_ss << "const size_t rom_size = " << rom_size << ";\n";
    output.rom_data_content = rom_ss.str();
    output.rom_data_file = options.output_prefix + "_rom.c";
    
    // Generate main
    std::ostringstream main_ss;
    main_ss << "/* Main entry point */\n";
    main_ss << "#include \"" << options.output_prefix << ".h\"\n";
    main_ss << "#include \"gbrt.h\"\n";
    main_ss << "#ifdef GB_HAS_SDL2\n";
    main_ss << "#include \"platform_sdl.h\"\n";
    main_ss << "#endif\n";
    main_ss << "#include <stdio.h>\n";
    main_ss << "#include <stdlib.h>\n\n";
    main_ss << "int main(int argc, char* argv[]) {\n";
    main_ss << "    (void)argc; (void)argv;\n";
    main_ss << "    GBContext* ctx = gb_context_create(NULL);\n";
    main_ss << "    if (!ctx) {\n";
    main_ss << "        fprintf(stderr, \"Failed to create context\\n\");\n";
    main_ss << "        return 1;\n";
    main_ss << "    }\n";
    main_ss << "    " << options.output_prefix << "_init(ctx);\n";
    main_ss << "\n";
    main_ss << "#ifdef GB_HAS_SDL2\n";
    main_ss << "    // Initialize SDL2 platform with 3x scaling\n";
    main_ss << "    if (!gb_platform_init(3)) {\n";
    main_ss << "        fprintf(stderr, \"Failed to initialize platform\\n\");\n";
    main_ss << "        gb_context_destroy(ctx);\n";
    main_ss << "        return 1;\n";
    main_ss << "    }\n";
    main_ss << "\n";
    main_ss << "    // Run the game - rendering happens inside gb_halt()\n";
    main_ss << "    " << options.output_prefix << "_run(ctx);\n";
    main_ss << "\n";
    main_ss << "    gb_platform_shutdown();\n";
    main_ss << "#else\n";
    main_ss << "    // No SDL2 - just run for testing\n";
    main_ss << "    " << options.output_prefix << "_run(ctx);\n";
    main_ss << "    printf(\"Recompiled code executed successfully!\\n\");\n";
    main_ss << "    printf(\"Registers: A=%02X B=%02X C=%02X\\n\", ctx->a, ctx->b, ctx->c);\n";
    main_ss << "#endif\n";
    main_ss << "\n";
    main_ss << "    gb_context_destroy(ctx);\n";
    main_ss << "    return 0;\n";
    main_ss << "}\n";
    output.main_content = main_ss.str();
    output.main_file = options.output_prefix + "_main.c";
    
    // Generate CMakeLists.txt
    std::ostringstream cmake_ss;
    cmake_ss << "cmake_minimum_required(VERSION 3.16)\n";
    cmake_ss << "project(" << options.output_prefix << " C)\n\n";
    cmake_ss << "# Set C standard\n";
    cmake_ss << "set(CMAKE_C_STANDARD 11)\n";
    cmake_ss << "set(CMAKE_C_STANDARD_REQUIRED ON)\n\n";
    cmake_ss << "# Runtime library path (relative to this output directory)\n";
    cmake_ss << "set(GBRT_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/../runtime\")\n\n";
    cmake_ss << "# Find SDL2\n";
    cmake_ss << "find_package(SDL2 REQUIRED)\n\n";
    cmake_ss << "# Create runtime library with PPU and platform support\n";
    cmake_ss << "add_library(gbrt STATIC\n";
    cmake_ss << "    ${GBRT_DIR}/src/gbrt.c\n";
    cmake_ss << "    ${GBRT_DIR}/src/ppu.c\n";
    cmake_ss << "    ${GBRT_DIR}/src/audio.c\n";
    cmake_ss << "    ${GBRT_DIR}/src/interpreter.c\n";
    cmake_ss << "    ${GBRT_DIR}/src/platform_sdl.c\n";
    cmake_ss << ")\n";
    cmake_ss << "target_include_directories(gbrt PUBLIC ${GBRT_DIR}/include)\n";
    cmake_ss << "target_link_libraries(gbrt PUBLIC SDL2::SDL2)\n";
    cmake_ss << "target_compile_definitions(gbrt PUBLIC GB_HAS_SDL2)\n\n";
    cmake_ss << "# Main executable\n";
    cmake_ss << "add_executable(" << options.output_prefix << "\n";
    cmake_ss << "    " << options.output_prefix << "_main.c\n";
    cmake_ss << "    " << options.output_prefix << ".c\n";
    cmake_ss << "    " << options.output_prefix << "_rom.c\n";
    cmake_ss << ")\n\n";
    cmake_ss << "target_link_libraries(" << options.output_prefix << " gbrt)\n";
    output.cmake_content = cmake_ss.str();
    output.cmake_file = "CMakeLists.txt";
    
    return output;
}

bool write_output(const GeneratedOutput& output, const std::string& output_dir) {
    namespace fs = std::filesystem;
    
    try {
        // Create output directory if it doesn't exist
        fs::path out_path(output_dir);
        if (!fs::exists(out_path)) {
            fs::create_directories(out_path);
        }
        
        // Write header file
        std::ofstream header_file(out_path / output.header_file);
        if (!header_file) return false;
        header_file << output.header_content;
        header_file.close();
        
        // Write source file
        std::ofstream source_file(out_path / output.source_file);
        if (!source_file) return false;
        source_file << output.source_content;
        source_file.close();
        
        // Write ROM data file
        std::ofstream rom_file(out_path / output.rom_data_file);
        if (!rom_file) return false;
        rom_file << output.rom_data_content;
        rom_file.close();
        
        // Write main file
        std::ofstream main_file(out_path / output.main_file);
        if (!main_file) return false;
        main_file << output.main_content;
        main_file.close();
        
        // Write CMakeLists.txt
        std::ofstream cmake_file(out_path / output.cmake_file);
        if (!cmake_file) return false;
        cmake_file << output.cmake_content;
        cmake_file.close();
        
        return true;
    } catch (...) {
        return false;
    }
}

} // namespace codegen
} // namespace gbrecomp
