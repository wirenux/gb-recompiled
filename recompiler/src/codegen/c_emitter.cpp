/**
 * @file c_emitter.cpp
 * @brief C code emitter implementation (MVP)
 */

#include "recompiler/codegen/c_emitter.h"
#include <iomanip>
#include <fstream>
#include <filesystem>

namespace gbrecomp {
namespace codegen {

/* ============================================================================
 * CEmitter Constructor
 * ========================================================================== */

CEmitter::CEmitter(std::ostream& output, const GeneratorOptions& options)
    : out_(output), options_(options), indent_level_(0) {}

/* ============================================================================
 * Helper Methods
 * ========================================================================== */

void CEmitter::emit_indent() {
    for (int i = 0; i < indent_level_; i++) {
        out_ << "    ";
    }
}

void CEmitter::emit_line(const std::string& line) {
    emit_indent();
    out_ << line << "\n";
}

const char* CEmitter::reg8_name(uint8_t reg) {
    static const char* names[] = {"A", "B", "C", "D", "E", "H", "L", "(HL)"};
    return reg < 8 ? names[reg] : "?";
}

const char* CEmitter::reg16_name(uint8_t reg) {
    static const char* names[] = {"BC", "DE", "HL", "SP", "AF"};
    return reg < 5 ? names[reg] : "?";
}

const char* CEmitter::condition_code(uint8_t cc) {
    static const char* names[] = {"NZ", "Z", "NC", "C"};
    return cc < 4 ? names[cc] : "?";
}

const char* CEmitter::condition_expr(uint8_t cc) {
    switch (cc) {
        case 0: return "!FLAG_Z(ctx)";   // NZ
        case 1: return "FLAG_Z(ctx)";    // Z
        case 2: return "!FLAG_C(ctx)";   // NC
        case 3: return "FLAG_C(ctx)";    // C
        default: return "true";
    }
}

/* ============================================================================
 * Program Structure
 * ========================================================================== */

void CEmitter::begin_program(const std::string& name) {
    out_ << "/* Generated by gbrecomp from " << name << " */\n";
    out_ << "#include \"gbrt.h\"\n\n";
    current_function_ = "";
}

void CEmitter::end_program() {
    out_ << "\n/* End of generated code */\n";
}

void CEmitter::begin_function(const std::string& name, uint8_t bank, uint16_t addr) {
    out_ << "\n/* Function at ";
    if (bank > 0) {
        out_ << std::hex << std::setfill('0') << std::setw(2) << (int)bank << ":";
    }
    out_ << std::hex << std::setfill('0') << std::setw(4) << addr << std::dec << " */\n";
    out_ << "void " << name << "(GBContext* ctx) {\n";
    current_function_ = name;
    indent_level_ = 1;
}

void CEmitter::end_function() {
    indent_level_ = 0;
    out_ << "}\n";
    current_function_ = "";
}

void CEmitter::emit_label(const std::string& label) {
    // Labels are at indent 0, code at indent 1
    out_ << label << ":\n";
}

/* ============================================================================
 * Data Movement
 * ========================================================================== */

void CEmitter::emit_mov_reg_reg(uint8_t dst, uint8_t src) {
    emit_indent();
    out_ << "ctx->" << reg8_name(dst) << " = ctx->" << reg8_name(src) << ";\n";
}

void CEmitter::emit_mov_reg_imm8(uint8_t dst, uint8_t imm) {
    emit_indent();
    out_ << "ctx->" << reg8_name(dst) << " = 0x" << std::hex << std::setfill('0') 
         << std::setw(2) << (int)imm << std::dec << ";\n";
}

void CEmitter::emit_mov_reg16_imm16(uint8_t dst, uint16_t imm) {
    emit_indent();
    out_ << "gbrt_set_" << reg16_name(dst) << "(ctx, 0x" << std::hex << std::setfill('0') 
         << std::setw(4) << imm << std::dec << ");\n";
}

void CEmitter::emit_load8_addr(uint8_t dst, uint16_t addr) {
    emit_indent();
    out_ << "ctx->" << reg8_name(dst) << " = gbrt_read8(ctx, 0x" << std::hex 
         << std::setfill('0') << std::setw(4) << addr << std::dec << ");\n";
}

void CEmitter::emit_load8_reg(uint8_t dst, uint8_t addr_reg) {
    emit_indent();
    out_ << "ctx->" << reg8_name(dst) << " = gbrt_read8(ctx, gbrt_get_" 
         << reg16_name(addr_reg) << "(ctx));\n";
}

void CEmitter::emit_load16_addr(uint8_t dst, uint16_t addr) {
    emit_indent();
    out_ << "gbrt_set_" << reg16_name(dst) << "(ctx, gbrt_read16(ctx, 0x" << std::hex 
         << std::setfill('0') << std::setw(4) << addr << std::dec << "));\n";
}

void CEmitter::emit_store8_addr(uint16_t addr, uint8_t src) {
    emit_indent();
    out_ << "gbrt_write8(ctx, 0x" << std::hex << std::setfill('0') << std::setw(4) 
         << addr << std::dec << ", ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_store8_reg(uint8_t addr_reg, uint8_t src) {
    emit_indent();
    out_ << "gbrt_write8(ctx, gbrt_get_" << reg16_name(addr_reg) << "(ctx), ctx->" 
         << reg8_name(src) << ");\n";
}

void CEmitter::emit_store16_addr(uint16_t addr, uint8_t src) {
    emit_indent();
    out_ << "gbrt_write16(ctx, 0x" << std::hex << std::setfill('0') << std::setw(4) 
         << addr << std::dec << ", gbrt_get_" << reg16_name(src) << "(ctx));\n";
}

void CEmitter::emit_push(uint8_t reg16) {
    emit_indent();
    out_ << "gbrt_push16(ctx, gbrt_get_" << reg16_name(reg16) << "(ctx));\n";
}

void CEmitter::emit_pop(uint8_t reg16) {
    emit_indent();
    out_ << "gbrt_set_" << reg16_name(reg16) << "(ctx, gbrt_pop16(ctx));\n";
}

/* ============================================================================
 * ALU Operations
 * ========================================================================== */

void CEmitter::emit_add_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_add_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_add_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_add_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_adc_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_adc_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_adc_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_adc_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_sub_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_sub_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_sub_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_sub_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_sbc_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_sbc_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_sbc_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_sbc_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_and_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_and_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_and_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_and_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_or_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_or_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_or_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_or_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_xor_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_xor_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_xor_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_xor_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_cp_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_cp_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_cp_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_cp_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_inc_reg8(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_inc8(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_dec_reg8(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_dec8(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_inc_reg16(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_set_" << reg16_name(reg) << "(ctx, gbrt_get_" << reg16_name(reg) 
         << "(ctx) + 1);\n";
}

void CEmitter::emit_dec_reg16(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_set_" << reg16_name(reg) << "(ctx, gbrt_get_" << reg16_name(reg) 
         << "(ctx) - 1);\n";
}

void CEmitter::emit_inc_mem_hl() {
    emit_line("gbrt_inc_mem_hl(ctx);");
}

void CEmitter::emit_dec_mem_hl() {
    emit_line("gbrt_dec_mem_hl(ctx);");
}

void CEmitter::emit_add_hl_reg16(uint8_t src) {
    emit_indent();
    out_ << "gbrt_add_hl(ctx, gbrt_get_" << reg16_name(src) << "(ctx));\n";
}

void CEmitter::emit_add_sp_imm8(int8_t offset) {
    emit_indent();
    out_ << "gbrt_add_sp(ctx, " << (int)offset << ");\n";
}

/* ============================================================================
 * Bit Operations
 * ========================================================================== */

void CEmitter::emit_rlc_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_rlc(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_rrc_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_rrc(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_rl_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_rl(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_rr_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_rr(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_sla_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_sla(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_sra_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_sra(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_srl_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_srl(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_swap_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_swap(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_bit_n_reg(uint8_t bit, uint8_t reg) {
    emit_indent();
    out_ << "gbrt_bit(ctx, " << (int)bit << ", ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_set_n_reg(uint8_t bit, uint8_t reg) {
    emit_indent();
    out_ << "ctx->" << reg8_name(reg) << " |= (1 << " << (int)bit << ");\n";
}

void CEmitter::emit_res_n_reg(uint8_t bit, uint8_t reg) {
    emit_indent();
    out_ << "ctx->" << reg8_name(reg) << " &= ~(1 << " << (int)bit << ");\n";
}

void CEmitter::emit_rlc_hl() { emit_line("gbrt_rlc_hl(ctx);"); }
void CEmitter::emit_rrc_hl() { emit_line("gbrt_rrc_hl(ctx);"); }
void CEmitter::emit_rl_hl() { emit_line("gbrt_rl_hl(ctx);"); }
void CEmitter::emit_rr_hl() { emit_line("gbrt_rr_hl(ctx);"); }
void CEmitter::emit_sla_hl() { emit_line("gbrt_sla_hl(ctx);"); }
void CEmitter::emit_sra_hl() { emit_line("gbrt_sra_hl(ctx);"); }
void CEmitter::emit_srl_hl() { emit_line("gbrt_srl_hl(ctx);"); }
void CEmitter::emit_swap_hl() { emit_line("gbrt_swap_hl(ctx);"); }

void CEmitter::emit_bit_n_hl(uint8_t bit) {
    emit_indent();
    out_ << "gbrt_bit_hl(ctx, " << (int)bit << ");\n";
}

void CEmitter::emit_set_n_hl(uint8_t bit) {
    emit_indent();
    out_ << "gbrt_set_hl(ctx, " << (int)bit << ");\n";
}

void CEmitter::emit_res_n_hl(uint8_t bit) {
    emit_indent();
    out_ << "gbrt_res_hl(ctx, " << (int)bit << ");\n";
}

void CEmitter::emit_rlca() { emit_line("gbrt_rlca(ctx);"); }
void CEmitter::emit_rrca() { emit_line("gbrt_rrca(ctx);"); }
void CEmitter::emit_rla() { emit_line("gbrt_rla(ctx);"); }
void CEmitter::emit_rra() { emit_line("gbrt_rra(ctx);"); }

/* ============================================================================
 * Control Flow
 * ========================================================================== */

void CEmitter::emit_jump(const std::string& label) {
    emit_indent();
    out_ << "goto " << label << ";\n";
}

void CEmitter::emit_jump_cc(uint8_t cc, const std::string& label,
                            const std::string& fallthrough_label) {
    emit_indent();
    out_ << "if (" << condition_expr(cc) << ") goto " << label << ";\n";
    (void)fallthrough_label;  // Not needed with goto
}

void CEmitter::emit_jump_hl() {
    emit_line("gbrt_jump_hl(ctx); return;");
}

void CEmitter::emit_jr(int8_t offset, const std::string& label) {
    (void)offset;  // Using label instead
    emit_indent();
    out_ << "goto " << label << ";\n";
}

void CEmitter::emit_jr_cc(uint8_t cc, int8_t offset, const std::string& label,
                          const std::string& fallthrough_label) {
    (void)offset;
    emit_jump_cc(cc, label, fallthrough_label);
}

void CEmitter::emit_call(const std::string& func_name) {
    emit_indent();
    out_ << func_name << "(ctx);\n";
}

void CEmitter::emit_call_cc(uint8_t cc, const std::string& func_name,
                            const std::string& fallthrough_label) {
    emit_indent();
    out_ << "if (" << condition_expr(cc) << ") " << func_name << "(ctx);\n";
    (void)fallthrough_label;
}

void CEmitter::emit_rst(uint8_t vector) {
    emit_indent();
    out_ << "rst_" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)vector << std::dec << "(ctx);\n";
}

void CEmitter::emit_ret() {
    emit_line("return;");
}

void CEmitter::emit_ret_cc(uint8_t cc, const std::string& fallthrough_label) {
    emit_indent();
    out_ << "if (" << condition_expr(cc) << ") return;\n";
    (void)fallthrough_label;
}

void CEmitter::emit_reti() {
    emit_line("ctx->ime = 1;");
    emit_line("return;");
}

void CEmitter::emit_bank_call(uint8_t target_bank, const std::string& func_name) {
    emit_indent();
    out_ << "gbrt_bank_call(ctx, " << (int)target_bank << ", " << func_name << ");\n";
}

void CEmitter::emit_bank_dispatch(uint16_t addr) {
    emit_indent();
    out_ << "gbrt_bank_dispatch(ctx, 0x" << std::hex << std::setfill('0') 
         << std::setw(4) << addr << std::dec << ");\n";
}

/* ============================================================================
 * Special Instructions
 * ========================================================================== */

void CEmitter::emit_nop() {
    // No-op - can emit nothing or a comment
    if (options_.emit_comments) {
        emit_line("/* NOP */");
    }
}

void CEmitter::emit_halt() { emit_line("gbrt_halt(ctx);"); }
void CEmitter::emit_stop() { emit_line("gbrt_stop(ctx);"); }
void CEmitter::emit_di() { emit_line("ctx->ime = 0;"); }
void CEmitter::emit_ei() { emit_line("ctx->ime_scheduled = 1;"); }
void CEmitter::emit_daa() { emit_line("gbrt_daa(ctx);"); }
void CEmitter::emit_cpl() { emit_line("gbrt_cpl(ctx);"); }
void CEmitter::emit_ccf() { emit_line("gbrt_ccf(ctx);"); }
void CEmitter::emit_scf() { emit_line("gbrt_scf(ctx);"); }

/* ============================================================================
 * I/O
 * ========================================================================== */

void CEmitter::emit_ldh_a_n(uint8_t offset) {
    emit_indent();
    out_ << "ctx->A = gbrt_read8(ctx, 0xFF00 + 0x" << std::hex << std::setfill('0') 
         << std::setw(2) << (int)offset << std::dec << ");\n";
}

void CEmitter::emit_ldh_n_a(uint8_t offset) {
    emit_indent();
    out_ << "gbrt_write8(ctx, 0xFF00 + 0x" << std::hex << std::setfill('0') 
         << std::setw(2) << (int)offset << std::dec << ", ctx->A);\n";
}

void CEmitter::emit_ldh_a_c() {
    emit_line("ctx->A = gbrt_read8(ctx, 0xFF00 + ctx->C);");
}

void CEmitter::emit_ldh_c_a() {
    emit_line("gbrt_write8(ctx, 0xFF00 + ctx->C, ctx->A);");
}

/* ============================================================================
 * Memory with increment/decrement
 * ========================================================================== */

void CEmitter::emit_ldi_a_hl() { emit_line("gbrt_ldi_a_hl(ctx);"); }
void CEmitter::emit_ldd_a_hl() { emit_line("gbrt_ldd_a_hl(ctx);"); }
void CEmitter::emit_ldi_hl_a() { emit_line("gbrt_ldi_hl_a(ctx);"); }
void CEmitter::emit_ldd_hl_a() { emit_line("gbrt_ldd_hl_a(ctx);"); }

/* ============================================================================
 * Debug/Comments
 * ========================================================================== */

void CEmitter::emit_comment(const std::string& comment) {
    if (options_.emit_comments) {
        emit_indent();
        out_ << "/* " << comment << " */\n";
    }
}

void CEmitter::emit_source_location(uint8_t bank, uint16_t addr) {
    if (options_.emit_address_comments) {
        emit_indent();
        out_ << "/* ";
        if (bank > 0) {
            out_ << std::hex << std::setfill('0') << std::setw(2) << (int)bank << ":";
        }
        out_ << std::hex << std::setfill('0') << std::setw(4) << addr << std::dec << " */\n";
    }
}

/* ============================================================================
 * Cycle Counting
 * ========================================================================== */

void CEmitter::emit_add_cycles(uint8_t cycles) {
    if (options_.emit_cycle_counting) {
        emit_indent();
        out_ << "ctx->cycles += " << (int)cycles << ";\n";
    }
}

void CEmitter::emit_yield_check() {
    emit_line("if (ctx->cycles >= ctx->cycle_limit) return;");
}

/* ============================================================================
 * Output Generation Functions
 * ========================================================================== */

static const char* reg8_names[] = {"b", "c", "d", "e", "h", "l", "hl_ind", "a"};
static const char* reg16_names[] = {"bc", "de", "hl", "sp", "af"};
static const char* cond_names[] = {"NZ", "Z", "NC", "C"};

static void emit_ir_instruction(std::ostream& out, const ir::IRInstruction& instr, 
                                const ir::Program& program, int indent, 
                                const GeneratorOptions& options) {
    auto emit_indent = [&out, indent]() {
        for (int i = 0; i < indent; i++) out << "    ";
    };
    
    // Emit source location comment if enabled
    if (options.emit_address_comments && instr.source_address != 0) {
        emit_indent();
        out << "/* " << std::hex << std::setfill('0');
        if (instr.source_bank > 0) {
            out << std::setw(2) << (int)instr.source_bank << ":";
        }
        out << std::setw(4) << instr.source_address << std::dec << " */ ";
    }
    
    // Comment (usually disassembly)
    if (!instr.comment.empty() && options.emit_comments) {
        emit_indent();
        out << "/* " << instr.comment << " */\n";
        return;  // Comment-only instruction
    }
    
    emit_indent();
    
    switch (instr.opcode) {
        case ir::Opcode::NOP:
            out << "/* NOP */\n";
            break;
            
        case ir::Opcode::MOV_REG_REG:
            out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                << " = ctx->" << reg8_names[instr.src.value.reg8] << ";\n";
            break;
            
        case ir::Opcode::MOV_REG_IMM8:
            out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                << " = 0x" << std::hex << std::setfill('0') << std::setw(2) 
                << (int)instr.src.value.imm8 << std::dec << ";\n";
            break;
            
        case ir::Opcode::MOV_REG_IMM16:
            out << "ctx->" << reg16_names[instr.dst.value.reg16] 
                << " = 0x" << std::hex << std::setfill('0') << std::setw(4) 
                << instr.src.value.imm16 << std::dec << ";\n";
            break;
            
        case ir::Opcode::LOAD8:
            out << "ctx->a = gb_read8(ctx, 0x" << std::hex << std::setfill('0') 
                << std::setw(4) << instr.src.value.imm16 << std::dec << ");\n";
            break;
            
        case ir::Opcode::STORE8:
            if (instr.dst.type == ir::OperandType::IMM16) {
                out << "gb_write8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(4) << instr.dst.value.imm16 << std::dec 
                    << ", ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            } else if (instr.dst.type == ir::OperandType::REG16) {
                out << "gb_write8(ctx, ctx->" << reg16_names[instr.dst.value.reg16] 
                    << ", ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::ADD8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_add8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_add8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::ADC8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_adc8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_adc8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::SUB8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_sub8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_sub8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::SBC8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_sbc8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_sbc8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::AND8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_and8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_and8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::OR8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_or8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_or8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::XOR8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_xor8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_xor8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::CP8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_cp8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_cp8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::INC8:
            out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                << " = gb_inc8(ctx, ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            break;
            
        case ir::Opcode::DEC8:
            out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                << " = gb_dec8(ctx, ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            break;
            
        case ir::Opcode::INC16:
            out << "ctx->" << reg16_names[instr.dst.value.reg16] << "++;\n";
            break;
            
        case ir::Opcode::DEC16:
            out << "ctx->" << reg16_names[instr.dst.value.reg16] << "--;\n";
            break;
            
        case ir::Opcode::ADD16:
            out << "gb_add16(ctx, ctx->" << reg16_names[instr.src.value.reg16] << ");\n";
            break;
            
        case ir::Opcode::ADD_SP_IMM8:
            out << "gb_add_sp(ctx, " << (int)instr.src.value.offset << ");\n";
            break;
            
        case ir::Opcode::PUSH16:
            out << "gb_push16(ctx, ctx->" << reg16_names[instr.dst.value.reg16] << ");\n";
            break;
            
        case ir::Opcode::POP16:
            out << "ctx->" << reg16_names[instr.dst.value.reg16] << " = gb_pop16(ctx);\n";
            break;
            
        case ir::Opcode::JUMP:
            if (instr.dst.type == ir::OperandType::IMM16) {
                out << "goto loc_" << std::hex << std::setfill('0') 
                    << std::setw(4) << instr.dst.value.imm16 << std::dec << ";\n";
            } else {
                out << "gb_dispatch(ctx, ctx->hl);\n";
            }
            break;
            
        case ir::Opcode::JUMP_CC: {
            const char* cond = cond_names[instr.src.value.condition];
            const char* expr = (instr.src.value.condition == 0) ? "!ctx->f_z" :
                               (instr.src.value.condition == 1) ? "ctx->f_z" :
                               (instr.src.value.condition == 2) ? "!ctx->f_c" : "ctx->f_c";
            out << "if (" << expr << ") goto loc_" << std::hex << std::setfill('0') 
                << std::setw(4) << instr.dst.value.imm16 << std::dec << "; /* " << cond << " */\n";
            break;
        }
            
        case ir::Opcode::CALL:
            out << "func_" << std::hex << std::setfill('0') 
                << std::setw(4) << instr.dst.value.imm16 << std::dec << "(ctx);\n";
            break;
            
        case ir::Opcode::CALL_CC: {
            const char* cond = cond_names[instr.src.value.condition];
            const char* expr = (instr.src.value.condition == 0) ? "!ctx->f_z" :
                               (instr.src.value.condition == 1) ? "ctx->f_z" :
                               (instr.src.value.condition == 2) ? "!ctx->f_c" : "ctx->f_c";
            out << "if (" << expr << ") func_" << std::hex << std::setfill('0') 
                << std::setw(4) << instr.dst.value.imm16 << std::dec << "(ctx); /* " << cond << " */\n";
            break;
        }
            
        case ir::Opcode::RET:
            out << "return;\n";
            break;
            
        case ir::Opcode::RET_CC: {
            const char* cond = cond_names[instr.src.value.condition];
            const char* expr = (instr.src.value.condition == 0) ? "!ctx->f_z" :
                               (instr.src.value.condition == 1) ? "ctx->f_z" :
                               (instr.src.value.condition == 2) ? "!ctx->f_c" : "ctx->f_c";
            out << "if (" << expr << ") return; /* " << cond << " */\n";
            break;
        }
            
        case ir::Opcode::RETI:
            out << "ctx->ime = 1; return;\n";
            break;
            
        case ir::Opcode::RST:
            out << "rst_" << std::hex << std::setfill('0') << std::setw(2) 
                << (int)instr.dst.value.rst_vec << std::dec << "(ctx);\n";
            break;
            
        case ir::Opcode::HALT:
            out << "gb_halt(ctx);\n";
            break;
            
        case ir::Opcode::STOP:
            out << "gb_stop(ctx);\n";
            break;
            
        case ir::Opcode::DI:
            out << "ctx->ime = 0;\n";
            break;
            
        case ir::Opcode::EI:
            out << "ctx->ime_pending = 1;\n";
            break;
            
        case ir::Opcode::DAA:
            out << "gb_daa(ctx);\n";
            break;
            
        case ir::Opcode::CPL:
            out << "ctx->a = ~ctx->a; ctx->f_n = 1; ctx->f_h = 1;\n";
            break;
            
        case ir::Opcode::SCF:
            out << "ctx->f_n = 0; ctx->f_h = 0; ctx->f_c = 1;\n";
            break;
            
        case ir::Opcode::CCF:
            out << "ctx->f_n = 0; ctx->f_h = 0; ctx->f_c = !ctx->f_c;\n";
            break;
            
        case ir::Opcode::BIT:
            out << "gb_bit(ctx, " << (int)instr.src.value.bit_idx 
                << ", ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            break;
            
        case ir::Opcode::SET:
            out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                << " |= (1 << " << (int)instr.src.value.bit_idx << ");\n";
            break;
            
        case ir::Opcode::RES:
            out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                << " &= ~(1 << " << (int)instr.src.value.bit_idx << ");\n";
            break;
            
        default:
            out << "/* Unhandled opcode */\n";
            break;
    }
    
    // Emit cycle counting if enabled
    if (options.emit_cycle_counting && instr.cycles > 0) {
        emit_indent();
        out << "ctx->cycles += " << (int)instr.cycles << ";\n";
    }
}

GeneratedOutput generate_output(const ir::Program& program,
                                const uint8_t* rom_data,
                                size_t rom_size,
                                const GeneratorOptions& options) {
    GeneratedOutput output;
    
    // Generate header
    std::ostringstream header_ss;
    header_ss << "/* Generated by gbrecomp */\n";
    header_ss << "#ifndef " << options.output_prefix << "_H\n";
    header_ss << "#define " << options.output_prefix << "_H\n\n";
    header_ss << "#include \"gbrt.h\"\n\n";
    header_ss << "void " << options.output_prefix << "_run(GBContext* ctx);\n";
    header_ss << "void " << options.output_prefix << "_init(GBContext* ctx);\n\n";
    header_ss << "#endif\n";
    output.header_content = header_ss.str();
    output.header_file = options.output_prefix + ".h";
    
    // Generate source
    std::ostringstream source_ss;
    source_ss << "/* Generated by gbrecomp from " << program.rom_name << " */\n";
    source_ss << "#include \"" << options.output_prefix << ".h\"\n";
    source_ss << "#include \"gbrt.h\"\n\n";
    
    // Forward declarations
    source_ss << "/* Forward declarations */\n";
    for (const auto& [name, func] : program.functions) {
        source_ss << "static void " << func.name << "(GBContext* ctx);\n";
    }
    source_ss << "\n";
    
    // Emit each function with real IR code
    for (const auto& [name, func] : program.functions) {
        source_ss << "/* Function at ";
        if (func.bank > 0) {
            source_ss << std::hex << std::setfill('0') << std::setw(2) << (int)func.bank << ":";
        }
        source_ss << std::hex << std::setfill('0') << std::setw(4) << func.entry_address << std::dec << " */\n";
        source_ss << "static void " << func.name << "(GBContext* ctx) {\n";
        
        // Emit each block in this function
        for (uint32_t block_id : func.block_ids) {
            auto block_it = program.blocks.find(block_id);
            if (block_it == program.blocks.end()) continue;
            const ir::BasicBlock& block = block_it->second;
            
            // Generate label from block address
            source_ss << "loc_" << std::hex << std::setfill('0') << std::setw(4) 
                      << block.start_address << std::dec << ":\n";
            
            // Emit each IR instruction
            for (const auto& ir_instr : block.instructions) {
                emit_ir_instruction(source_ss, ir_instr, program, 1, options);
            }
        }
        
        // If function is empty or has no terminator, add a return
        source_ss << "}\n\n";
    }
    
    // Emit init and run functions
    source_ss << "void " << options.output_prefix << "_init(GBContext* ctx) {\n";
    source_ss << "    (void)ctx; /* Already initialized by gb_context_create */\n";
    source_ss << "}\n\n";
    
    source_ss << "void " << options.output_prefix << "_run(GBContext* ctx) {\n";
    source_ss << "    gb_main(ctx);\n";  // Call the game's main function
    source_ss << "}\n";
    
    output.source_content = source_ss.str();
    output.source_file = options.output_prefix + ".c";
    
    // Generate ROM data
    std::ostringstream rom_ss;
    rom_ss << "/* ROM data */\n";
    rom_ss << "#include <stdint.h>\n\n";
    rom_ss << "const uint8_t rom_data[" << rom_size << "] = {\n";
    for (size_t i = 0; i < rom_size; i++) {
        if (i % 16 == 0) rom_ss << "    ";
        rom_ss << "0x" << std::hex << std::setfill('0') << std::setw(2) 
               << (int)rom_data[i];
        if (i < rom_size - 1) rom_ss << ",";
        if (i % 16 == 15 || i == rom_size - 1) rom_ss << "\n";
        else rom_ss << " ";
    }
    rom_ss << std::dec << "};\n";
    rom_ss << "const size_t rom_size = " << rom_size << ";\n";
    output.rom_data_content = rom_ss.str();
    output.rom_data_file = options.output_prefix + "_rom.c";
    
    // Generate main
    std::ostringstream main_ss;
    main_ss << "/* Main entry point */\n";
    main_ss << "#include \"" << options.output_prefix << ".h\"\n";
    main_ss << "#include \"gbrt.h\"\n";
    main_ss << "#include <stdio.h>\n";
    main_ss << "#include <stdlib.h>\n\n";
    main_ss << "int main(int argc, char* argv[]) {\n";
    main_ss << "    (void)argc; (void)argv;\n";
    main_ss << "    GBContext* ctx = gb_context_create(NULL);\n";
    main_ss << "    if (!ctx) {\n";
    main_ss << "        fprintf(stderr, \"Failed to create context\\n\");\n";
    main_ss << "        return 1;\n";
    main_ss << "    }\n";
    main_ss << "    " << options.output_prefix << "_init(ctx);\n";
    main_ss << "    " << options.output_prefix << "_run(ctx);\n";
    main_ss << "    printf(\"Recompiled code executed successfully!\\n\");\n";
    main_ss << "    printf(\"Registers: A=%02X B=%02X C=%02X\\n\", ctx->a, ctx->b, ctx->c);\n";
    main_ss << "    gb_context_destroy(ctx);\n";
    main_ss << "    return 0;\n";
    main_ss << "}\n";
    output.main_content = main_ss.str();
    output.main_file = options.output_prefix + "_main.c";
    
    // Generate CMakeLists.txt
    std::ostringstream cmake_ss;
    cmake_ss << "cmake_minimum_required(VERSION 3.16)\n";
    cmake_ss << "project(" << options.output_prefix << " C)\n\n";
    cmake_ss << "add_executable(" << options.output_prefix << "\n";
    cmake_ss << "    " << options.output_prefix << "_main.c\n";
    cmake_ss << "    " << options.output_prefix << ".c\n";
    cmake_ss << "    " << options.output_prefix << "_rom.c\n";
    cmake_ss << ")\n\n";
    cmake_ss << "target_link_libraries(" << options.output_prefix << " gbrt)\n";
    output.cmake_content = cmake_ss.str();
    output.cmake_file = "CMakeLists.txt";
    
    return output;
}

bool write_output(const GeneratedOutput& output, const std::string& output_dir) {
    namespace fs = std::filesystem;
    
    try {
        // Create output directory if it doesn't exist
        fs::path out_path(output_dir);
        if (!fs::exists(out_path)) {
            fs::create_directories(out_path);
        }
        
        // Write header file
        std::ofstream header_file(out_path / output.header_file);
        if (!header_file) return false;
        header_file << output.header_content;
        header_file.close();
        
        // Write source file
        std::ofstream source_file(out_path / output.source_file);
        if (!source_file) return false;
        source_file << output.source_content;
        source_file.close();
        
        // Write ROM data file
        std::ofstream rom_file(out_path / output.rom_data_file);
        if (!rom_file) return false;
        rom_file << output.rom_data_content;
        rom_file.close();
        
        // Write main file
        std::ofstream main_file(out_path / output.main_file);
        if (!main_file) return false;
        main_file << output.main_content;
        main_file.close();
        
        // Write CMakeLists.txt
        std::ofstream cmake_file(out_path / output.cmake_file);
        if (!cmake_file) return false;
        cmake_file << output.cmake_content;
        cmake_file.close();
        
        return true;
    } catch (...) {
        return false;
    }
}

} // namespace codegen
} // namespace gbrecomp
