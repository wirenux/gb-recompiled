/**
 * @file c_emitter.cpp
 * @brief C code emitter implementation (MVP)
 */

#include "recompiler/codegen/c_emitter.h"
#include <iomanip>
#include <iostream>
#include <fstream>
#include <filesystem>
#include <algorithm>

namespace gbrecomp {
namespace codegen {

/* ============================================================================
 * CEmitter Constructor
 * ========================================================================== */

CEmitter::CEmitter(std::ostream& output, const GeneratorOptions& options)
    : out_(output), options_(options), indent_level_(0) {}

/* ============================================================================
 * Helper Methods
 * ========================================================================== */

void CEmitter::emit_indent() {
    for (int i = 0; i < indent_level_; i++) {
        out_ << "    ";
    }
}

void CEmitter::emit_line(const std::string& line) {
    emit_indent();
    out_ << line << "\n";
}

const char* CEmitter::reg8_name(uint8_t reg) {
    static const char* names[] = {"A", "B", "C", "D", "E", "H", "L", "(HL)"};
    return reg < 8 ? names[reg] : "?";
}

const char* CEmitter::reg16_name(uint8_t reg) {
    static const char* names[] = {"BC", "DE", "HL", "SP", "AF"};
    return reg < 5 ? names[reg] : "?";
}

const char* CEmitter::condition_code(uint8_t cc) {
    static const char* names[] = {"NZ", "Z", "NC", "C"};
    return cc < 4 ? names[cc] : "?";
}

const char* CEmitter::condition_expr(uint8_t cc) {
    switch (cc) {
        case 0: return "!FLAG_Z(ctx)";   // NZ
        case 1: return "FLAG_Z(ctx)";    // Z
        case 2: return "!FLAG_C(ctx)";   // NC
        case 3: return "FLAG_C(ctx)";    // C
        default: return "true";
    }
}

/* ============================================================================
 * Program Structure
 * ========================================================================== */

void CEmitter::begin_program(const std::string& name) {
    out_ << "/* Generated by gbrecomp from " << name << " */\n";
    out_ << "#include \"gbrt.h\"\n\n";
    current_function_ = "";
}

void CEmitter::end_program() {
    out_ << "\n/* End of generated code */\n";
}

void CEmitter::begin_function(const std::string& name, uint8_t bank, uint16_t addr) {
    out_ << "\n/* Function at ";
    if (bank > 0) {
        out_ << std::hex << std::setfill('0') << std::setw(2) << (int)bank << ":";
    }
    out_ << std::hex << std::setfill('0') << std::setw(4) << addr << std::dec << " */\n";
    out_ << "void " << name << "(GBContext* ctx) {\n";
    current_function_ = name;
    indent_level_ = 1;
}

void CEmitter::end_function() {
    indent_level_ = 0;
    out_ << "}\n";
    current_function_ = "";
}

void CEmitter::emit_label(const std::string& label) {
    // Labels are at indent 0, code at indent 1
    out_ << label << ":\n";
}

/* ============================================================================
 * Data Movement
 * ========================================================================== */

void CEmitter::emit_mov_reg_reg(uint8_t dst, uint8_t src) {
    emit_indent();
    out_ << "ctx->" << reg8_name(dst) << " = ctx->" << reg8_name(src) << ";\n";
}

void CEmitter::emit_mov_reg_imm8(uint8_t dst, uint8_t imm) {
    emit_indent();
    out_ << "ctx->" << reg8_name(dst) << " = 0x" << std::hex << std::setfill('0') 
         << std::setw(2) << (int)imm << std::dec << ";\n";
}

void CEmitter::emit_mov_reg16_imm16(uint8_t dst, uint16_t imm) {
    emit_indent();
    out_ << "gbrt_set_" << reg16_name(dst) << "(ctx, 0x" << std::hex << std::setfill('0') 
         << std::setw(4) << imm << std::dec << ");\n";
}

void CEmitter::emit_load8_addr(uint8_t dst, uint16_t addr) {
    emit_indent();
    out_ << "ctx->" << reg8_name(dst) << " = gbrt_read8(ctx, 0x" << std::hex 
         << std::setfill('0') << std::setw(4) << addr << std::dec << ");\n";
}

void CEmitter::emit_load8_reg(uint8_t dst, uint8_t addr_reg) {
    emit_indent();
    out_ << "ctx->" << reg8_name(dst) << " = gbrt_read8(ctx, gbrt_get_" 
         << reg16_name(addr_reg) << "(ctx));\n";
}

void CEmitter::emit_load16_addr(uint8_t dst, uint16_t addr) {
    emit_indent();
    out_ << "gbrt_set_" << reg16_name(dst) << "(ctx, gbrt_read16(ctx, 0x" << std::hex 
         << std::setfill('0') << std::setw(4) << addr << std::dec << "));\n";
}

void CEmitter::emit_store8_addr(uint16_t addr, uint8_t src) {
    emit_indent();
    out_ << "gbrt_write8(ctx, 0x" << std::hex << std::setfill('0') << std::setw(4) 
         << addr << std::dec << ", ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_store8_reg(uint8_t addr_reg, uint8_t src) {
    emit_indent();
    out_ << "gbrt_write8(ctx, gbrt_get_" << reg16_name(addr_reg) << "(ctx), ctx->" 
         << reg8_name(src) << ");\n";
}

void CEmitter::emit_store16_addr(uint16_t addr, uint8_t src) {
    emit_indent();
    out_ << "gbrt_write16(ctx, 0x" << std::hex << std::setfill('0') << std::setw(4) 
         << addr << std::dec << ", gbrt_get_" << reg16_name(src) << "(ctx));\n";
}

void CEmitter::emit_push(uint8_t reg16) {
    emit_indent();
    out_ << "gbrt_push16(ctx, gbrt_get_" << reg16_name(reg16) << "(ctx));\n";
}

void CEmitter::emit_pop(uint8_t reg16) {
    emit_indent();
    out_ << "gbrt_set_" << reg16_name(reg16) << "(ctx, gbrt_pop16(ctx));\n";
}

/* ============================================================================
 * ALU Operations
 * ========================================================================== */

void CEmitter::emit_add_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_add_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_add_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_add_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_adc_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_adc_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_adc_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_adc_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_sub_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_sub_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_sub_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_sub_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_sbc_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_sbc_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_sbc_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_sbc_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_and_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_and_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_and_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_and_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_or_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_or_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_or_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_or_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_xor_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_xor_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_xor_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_xor_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_cp_a_reg(uint8_t src) {
    emit_indent();
    out_ << "gbrt_cp_a(ctx, ctx->" << reg8_name(src) << ");\n";
}

void CEmitter::emit_cp_a_imm(uint8_t imm) {
    emit_indent();
    out_ << "gbrt_cp_a(ctx, 0x" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)imm << std::dec << ");\n";
}

void CEmitter::emit_inc_reg8(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_inc8(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_dec_reg8(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_dec8(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_inc_reg16(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_set_" << reg16_name(reg) << "(ctx, gbrt_get_" << reg16_name(reg) 
         << "(ctx) + 1);\n";
}

void CEmitter::emit_dec_reg16(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_set_" << reg16_name(reg) << "(ctx, gbrt_get_" << reg16_name(reg) 
         << "(ctx) - 1);\n";
}

void CEmitter::emit_inc_mem_hl() {
    emit_line("gbrt_inc_mem_hl(ctx);");
}

void CEmitter::emit_dec_mem_hl() {
    emit_line("gbrt_dec_mem_hl(ctx);");
}

void CEmitter::emit_add_hl_reg16(uint8_t src) {
    emit_indent();
    out_ << "gbrt_add_hl(ctx, gbrt_get_" << reg16_name(src) << "(ctx));\n";
}

void CEmitter::emit_add_sp_imm8(int8_t offset) {
    emit_indent();
    out_ << "gbrt_add_sp(ctx, " << (int)offset << ");\n";
}

/* ============================================================================
 * Bit Operations
 * ========================================================================== */

void CEmitter::emit_rlc_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_rlc(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_rrc_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_rrc(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_rl_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_rl(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_rr_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_rr(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_sla_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_sla(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_sra_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_sra(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_srl_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_srl(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_swap_reg(uint8_t reg) {
    emit_indent();
    out_ << "gbrt_swap(ctx, &ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_bit_n_reg(uint8_t bit, uint8_t reg) {
    emit_indent();
    out_ << "gbrt_bit(ctx, " << (int)bit << ", ctx->" << reg8_name(reg) << ");\n";
}

void CEmitter::emit_set_n_reg(uint8_t bit, uint8_t reg) {
    emit_indent();
    out_ << "ctx->" << reg8_name(reg) << " |= (1 << " << (int)bit << ");\n";
}

void CEmitter::emit_res_n_reg(uint8_t bit, uint8_t reg) {
    emit_indent();
    out_ << "ctx->" << reg8_name(reg) << " &= ~(1 << " << (int)bit << ");\n";
}

void CEmitter::emit_rlc_hl() { emit_line("gbrt_rlc_hl(ctx);"); }
void CEmitter::emit_rrc_hl() { emit_line("gbrt_rrc_hl(ctx);"); }
void CEmitter::emit_rl_hl() { emit_line("gbrt_rl_hl(ctx);"); }
void CEmitter::emit_rr_hl() { emit_line("gbrt_rr_hl(ctx);"); }
void CEmitter::emit_sla_hl() { emit_line("gbrt_sla_hl(ctx);"); }
void CEmitter::emit_sra_hl() { emit_line("gbrt_sra_hl(ctx);"); }
void CEmitter::emit_srl_hl() { emit_line("gbrt_srl_hl(ctx);"); }
void CEmitter::emit_swap_hl() { emit_line("gbrt_swap_hl(ctx);"); }

void CEmitter::emit_bit_n_hl(uint8_t bit) {
    emit_indent();
    out_ << "gbrt_bit_hl(ctx, " << (int)bit << ");\n";
}

void CEmitter::emit_set_n_hl(uint8_t bit) {
    emit_indent();
    out_ << "gbrt_set_hl(ctx, " << (int)bit << ");\n";
}

void CEmitter::emit_res_n_hl(uint8_t bit) {
    emit_indent();
    out_ << "gbrt_res_hl(ctx, " << (int)bit << ");\n";
}

void CEmitter::emit_rlca() { emit_line("gbrt_rlca(ctx);"); }
void CEmitter::emit_rrca() { emit_line("gbrt_rrca(ctx);"); }
void CEmitter::emit_rla() { emit_line("gbrt_rla(ctx);"); }
void CEmitter::emit_rra() { emit_line("gbrt_rra(ctx);"); }

/* ============================================================================
 * Control Flow
 * ========================================================================== */

void CEmitter::emit_jump(const std::string& label) {
    emit_indent();
    out_ << "goto " << label << ";\n";
}

void CEmitter::emit_jump_cc(uint8_t cc, const std::string& label,
                            const std::string& fallthrough_label) {
    emit_indent();
    out_ << "if (" << condition_expr(cc) << ") goto " << label << ";\n";
    (void)fallthrough_label;  // Not needed with goto
}

void CEmitter::emit_jump_hl() {
    emit_line("gbrt_jump_hl(ctx); return;");
}

void CEmitter::emit_jr(int8_t offset, const std::string& label) {
    (void)offset;  // Using label instead
    emit_indent();
    out_ << "goto " << label << ";\n";
}

void CEmitter::emit_jr_cc(uint8_t cc, int8_t offset, const std::string& label,
                          const std::string& fallthrough_label) {
    (void)offset;
    emit_jump_cc(cc, label, fallthrough_label);
}

void CEmitter::emit_call(const std::string& func_name) {
    emit_indent();
    out_ << func_name << "(ctx);\n";
}

void CEmitter::emit_call_cc(uint8_t cc, const std::string& func_name,
                            const std::string& fallthrough_label) {
    emit_indent();
    out_ << "if (" << condition_expr(cc) << ") " << func_name << "(ctx);\n";
    (void)fallthrough_label;
}

void CEmitter::emit_rst(uint8_t vector) {
    emit_indent();
    out_ << "rst_" << std::hex << std::setfill('0') << std::setw(2) 
         << (int)vector << std::dec << "(ctx);\n";
}

void CEmitter::emit_ret() {
    emit_line("return;");
}

void CEmitter::emit_ret_cc(uint8_t cc, const std::string& fallthrough_label) {
    emit_indent();
    out_ << "if (" << condition_expr(cc) << ") return;\n";
    (void)fallthrough_label;
}

void CEmitter::emit_reti() {
    emit_line("ctx->ime = 1;");
    emit_line("return;");
}

void CEmitter::emit_bank_call(uint8_t target_bank, const std::string& func_name) {
    emit_indent();
    out_ << "gbrt_bank_call(ctx, " << (int)target_bank << ", " << func_name << ");\n";
}

void CEmitter::emit_bank_dispatch(uint16_t addr) {
    emit_indent();
    out_ << "gbrt_bank_dispatch(ctx, 0x" << std::hex << std::setfill('0') 
         << std::setw(4) << addr << std::dec << ");\n";
}

/* ============================================================================
 * Special Instructions
 * ========================================================================== */

void CEmitter::emit_nop() {
    // No-op - can emit nothing or a comment
    if (options_.emit_comments) {
        emit_line("/* NOP */");
    }
}

void CEmitter::emit_halt(uint16_t next_pc) {
    emit_indent();
    out_ << "if (!ctx->ime && (gbrt_read8(ctx, 0xFFFF) & gbrt_read8(ctx, 0xFF0F) & 0x1F)) {\n";
    indent_level_++;
    emit_indent();
    out_ << "ctx->halt_bug = 1;\n";
    emit_indent();
    out_ << "ctx->pc = 0x" << std::hex << next_pc << std::dec << ";\n";
    emit_indent();
    out_ << "return;\n";
    indent_level_--;
    emit_indent();
    out_ << "} else {\n";
    indent_level_++;
    emit_line("gbrt_halt(ctx);");
    indent_level_--;
    emit_indent();
    out_ << "}\n";
}
void CEmitter::emit_stop() { emit_line("gbrt_stop(ctx);"); }
void CEmitter::emit_di() { emit_line("ctx->ime = 0;"); }
void CEmitter::emit_ei() { emit_line("ctx->ime_scheduled = 1;"); }
void CEmitter::emit_daa() { emit_line("gbrt_daa(ctx);"); }
void CEmitter::emit_cpl() { emit_line("gbrt_cpl(ctx);"); }
void CEmitter::emit_ccf() { emit_line("gbrt_ccf(ctx);"); }
void CEmitter::emit_scf() { emit_line("gbrt_scf(ctx);"); }

/* ============================================================================
 * I/O
 * ========================================================================== */

void CEmitter::emit_ldh_a_n(uint8_t offset) {
    emit_indent();
    out_ << "ctx->A = gbrt_read8(ctx, 0xFF00 + 0x" << std::hex << std::setfill('0') 
         << std::setw(2) << (int)offset << std::dec << ");\n";
}

void CEmitter::emit_ldh_n_a(uint8_t offset) {
    emit_indent();
    out_ << "gbrt_write8(ctx, 0xFF00 + 0x" << std::hex << std::setfill('0') 
         << std::setw(2) << (int)offset << std::dec << ", ctx->A);\n";
}

void CEmitter::emit_ldh_a_c() {
    emit_line("ctx->A = gbrt_read8(ctx, 0xFF00 + ctx->C);");
}

void CEmitter::emit_ldh_c_a() {
    emit_line("gbrt_write8(ctx, 0xFF00 + ctx->C, ctx->A);");
}

/* ============================================================================
 * Memory with increment/decrement
 * ========================================================================== */

void CEmitter::emit_ldi_a_hl() { emit_line("gbrt_ldi_a_hl(ctx);"); }
void CEmitter::emit_ldd_a_hl() { emit_line("gbrt_ldd_a_hl(ctx);"); }
void CEmitter::emit_ldi_hl_a() { emit_line("gbrt_ldi_hl_a(ctx);"); }
void CEmitter::emit_ldd_hl_a() { emit_line("gbrt_ldd_hl_a(ctx);"); }

/* ============================================================================
 * Debug/Comments
 * ========================================================================== */

void CEmitter::emit_comment(const std::string& comment) {
    if (options_.emit_comments) {
        emit_indent();
        out_ << "/* " << comment << " */\n";
    }
}

void CEmitter::emit_source_location(uint8_t bank, uint16_t addr) {
    if (options_.emit_address_comments) {
        emit_indent();
        out_ << "/* ";
        if (bank > 0) {
            out_ << std::hex << std::setfill('0') << std::setw(2) << (int)bank << ":";
        }
        out_ << std::hex << std::setfill('0') << std::setw(4) << addr << std::dec << " */\n";
    }
}

/* ============================================================================
 * Cycle Counting
 * ========================================================================== */

void CEmitter::emit_add_cycles(uint8_t cycles) {
    if (options_.emit_cycle_counting) {
        emit_indent();
        out_ << "gb_tick(ctx, " << (int)cycles << ");\n";
        emit_indent();
        out_ << "if (ctx->stopped) return;\n";
    }
}

void CEmitter::emit_yield_check() {
    emit_line("if (ctx->cycles >= ctx->cycle_limit) return;");
}

/* ============================================================================
 * Output Generation Functions
 * ========================================================================== */

static const char* reg8_names[] = {"b", "c", "d", "e", "h", "l", nullptr, "a"};
static const char* reg16_names[] = {"bc", "de", "hl", "sp", "af"};
static const char* cond_names[] = {"NZ", "Z", "NC", "C"};

static const char* get_reg8_name(int idx) {
    if (idx < 0 || idx > 7 || idx == 6) return nullptr;
    return reg8_names[idx];
}

static void emit_ir_instruction(std::ostream& out, const ir::IRInstruction& instr, 
                                const ir::Program& program, int indent, 
                                const GeneratorOptions& options,
                                uint16_t next_pc_val,
                                uint32_t group_cycles,
                                bool is_last_in_group,
                                const std::string& current_func_name = "") {
    auto emit_indent = [&out, indent]() {
        for (int i = 0; i < indent; i++) out << "    ";
    };
    
    // Emit source location comment if enabled
    if (options.emit_address_comments && instr.has_source_location) {
        emit_indent();
        out << "/* " << std::hex << std::setfill('0');
        if (instr.source_bank > 0) {
            out << std::setw(2) << (int)instr.source_bank << ":";
        }
        out << std::setw(4) << instr.source_address << std::dec << " */ ";
    }
    
    // Comment (usually disassembly)
    if (!instr.comment.empty() && options.emit_comments) {
        emit_indent();
        out << "/* " << instr.comment << " */\n";
        return;  // Comment-only instruction
    }
    
    emit_indent();
    
    switch (instr.opcode) {
        case ir::Opcode::NOP:
            out << "/* NOP */\n";
            break;
            
        case ir::Opcode::MOV_REG_REG:
            out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                << " = ctx->" << reg8_names[instr.src.value.reg8] << ";\n";
            break;
            
        case ir::Opcode::MOV_REG_IMM8:
            out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                << " = 0x" << std::hex << std::setfill('0') << std::setw(2) 
                << (int)instr.src.value.imm8 << std::dec << ";\n";
            break;
            
        case ir::Opcode::MOV_REG_IMM16:
            out << "ctx->" << reg16_names[instr.dst.value.reg16] 
                << " = 0x" << std::hex << std::setfill('0') << std::setw(4) 
                << instr.src.value.imm16 << std::dec << ";\n";
            break;
            
        case ir::Opcode::LOAD8: {
            const char* dst_name = get_reg8_name(instr.dst.value.reg8);
            if (!dst_name) dst_name = "a";
            
            if (instr.src.type == ir::OperandType::IMM16) {
                out << "ctx->" << dst_name << " = gb_read8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(4) << instr.src.value.imm16 << std::dec << ");\n";
            } else if (instr.src.type == ir::OperandType::REG16) {
                out << "ctx->" << dst_name << " = gb_read8(ctx, ctx->" 
                    << reg16_names[instr.src.value.reg16] << ");\n";
            } else if (instr.src.type == ir::OperandType::REG8) {
                // LDH A,(C) - 0xFF00 + C
                out << "ctx->" << dst_name << " = gb_read8(ctx, 0xFF00 + ctx->c);\n";
            } else {
                out << "ctx->a = gb_read8(ctx, ctx->hl);\n";
            }
            break;
        }
            
        case ir::Opcode::STORE8:
            if (instr.dst.type == ir::OperandType::IMM16) {
                const char* src_name = get_reg8_name(instr.src.value.reg8);
                if (src_name) {
                    out << "gb_write8(ctx, 0x" << std::hex << std::setfill('0') 
                        << std::setw(4) << instr.dst.value.imm16 << std::dec 
                        << ", ctx->" << src_name << ");\n";
                } else if (instr.src.type == ir::OperandType::IMM8) {
                    out << "gb_write8(ctx, 0x" << std::hex << std::setfill('0') 
                        << std::setw(4) << instr.dst.value.imm16 << std::dec 
                        << ", 0x" << std::setw(2) << (int)instr.src.value.imm8 << ");\n";
                } else {
                    out << "gb_write8(ctx, 0x" << std::hex << std::setfill('0') 
                        << std::setw(4) << instr.dst.value.imm16 << std::dec 
                        << ", ctx->a);\n";
                }
            } else if (instr.dst.type == ir::OperandType::REG16) {
                const char* src_name = get_reg8_name(instr.src.value.reg8);
                if (src_name) {
                    out << "gb_write8(ctx, ctx->" << reg16_names[instr.dst.value.reg16] 
                        << ", ctx->" << src_name << ");\n";
                } else if (instr.src.type == ir::OperandType::IMM8) {
                    out << "gb_write8(ctx, ctx->" << reg16_names[instr.dst.value.reg16] 
                        << ", 0x" << std::hex << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
                } else {
                    out << "gb_write8(ctx, ctx->" << reg16_names[instr.dst.value.reg16] 
                        << ", ctx->a);\n";
                }
            }
            break;
            
        case ir::Opcode::ADD8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_add8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_add8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::ADC8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_adc8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_adc8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::SUB8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_sub8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_sub8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::SBC8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_sbc8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_sbc8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::AND8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_and8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_and8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::OR8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_or8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_or8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::XOR8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_xor8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_xor8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::CP8:
            if (instr.src.type == ir::OperandType::IMM8) {
                out << "gb_cp8(ctx, 0x" << std::hex << std::setfill('0') 
                    << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            } else {
                out << "gb_cp8(ctx, ctx->" << reg8_names[instr.src.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::INC8:
            if (instr.dst.value.reg8 == 6) {
                // INC (HL) - read-modify-write memory at address HL
                out << "gb_write8(ctx, ctx->hl, gb_inc8(ctx, gb_read8(ctx, ctx->hl)));\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " = gb_inc8(ctx, ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::DEC8:
            if (instr.dst.value.reg8 == 6) {
                // DEC (HL) - read-modify-write memory at address HL
                out << "gb_write8(ctx, ctx->hl, gb_dec8(ctx, gb_read8(ctx, ctx->hl)));\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " = gb_dec8(ctx, ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::INC16:
            out << "ctx->" << reg16_names[instr.dst.value.reg16] << "++;\n";
            break;
            
        case ir::Opcode::DEC16:
            out << "ctx->" << reg16_names[instr.dst.value.reg16] << "--;\n";
            break;
            
        case ir::Opcode::ADD16:
            out << "gb_add16(ctx, ctx->" << reg16_names[instr.src.value.reg16] << ");\n";
            break;
            
        case ir::Opcode::ADD_SP_IMM8:
            out << "gb_add_sp(ctx, " << (int)instr.src.value.offset << ");\n";
                break;
                
            case ir::Opcode::PUSH16:
                if (instr.dst.value.reg16 == 4) { // AF
                    out << "gb_pack_flags(ctx); gb_push16(ctx, ctx->af & 0xFFF0);\n";
                } else {
                    out << "gb_push16(ctx, ctx->" << reg16_names[instr.dst.value.reg16] << ");\n";
                }
                break;
                
            case ir::Opcode::POP16:
                if (instr.dst.value.reg16 == 4) { // AF
                    out << "ctx->af = gb_pop16(ctx) & 0xFFF0; gb_unpack_flags(ctx);\n";
                } else {
                    out << "ctx->" << reg16_names[instr.dst.value.reg16] << " = gb_pop16(ctx);\n";
                }
                break;
                
        case ir::Opcode::JUMP:
            if (instr.dst.type == ir::OperandType::IMM16) {
                uint16_t target = instr.dst.value.imm16;
                uint8_t tbank = instr.dst.bank;
                
                if (tbank == 255) {
                    if (options.emit_cycle_counting && instr.cycles > 0) {
                        out << "gb_tick(ctx, " << (int)instr.cycles << ");\n";
                        emit_indent();
                    }
                    out << "ctx->pc = 0x" << std::hex << std::setfill('0') 
                        << std::setw(4) << target << std::dec << "; return;\n";
                } else {
                    std::string target_func = program.make_function_name(tbank, target);
                    bool func_exists = program.functions.find(target_func) != program.functions.end();
                    
                    // If the target is a function entry, check if it's the current function
                    if (func_exists && target_func == current_func_name) {
                        // Same function: use goto
                        if (options.emit_cycle_counting && group_cycles > 0) {
                            out << "ctx->pc = 0x" << std::hex << target << std::dec << ";\n";
                            emit_indent();
                            out << "gb_tick(ctx, " << (int)group_cycles << ");\n";
                            emit_indent();
                            out << "if (ctx->stopped) return;\n";
                        } else {
                            out << "ctx->pc = 0x" << std::hex << target << std::dec << ";\n";
                        }
                        emit_indent();
                        out << "goto loc_" << std::hex << std::setfill('0') 
                            << std::setw(4) << target << std::dec << ";\n";
                    } else if (func_exists) {
                        // Different function or cross-bank: call and return
                        if (options.emit_cycle_counting && instr.cycles > 0) {
                            out << "gb_tick(ctx, " << (int)instr.cycles << ");\n";
                            emit_indent();
                        }
                        out << "ctx->pc = 0x" << std::hex << target << std::dec << ";\n";
                        emit_indent();
                        
                        // Direct call
                        out << target_func << "(ctx);\n";
                        emit_indent();
                        out << "return;\n";
                    } else {
                        // Not a recompiled function, use dispatcher
                        if (options.emit_cycle_counting && instr.cycles > 0) {
                            out << "gb_tick(ctx, " << (int)instr.cycles << ");\n";
                            emit_indent();
                        }
                        out << "ctx->pc = 0x" << std::hex << std::setfill('0') 
                            << std::setw(4) << target << std::dec << "; return;\n";
                    }
                }
            } else if (instr.dst.type == ir::OperandType::REG16) {
                // Indirect jump via register (JP HL)
                out << "gbrt_jump_hl(ctx);\n";
                if (options.emit_cycle_counting && group_cycles > 0) {
                    emit_indent();
                    out << "gb_tick(ctx, " << (int)group_cycles << ");\n";
                    emit_indent(); out << "if (ctx->stopped) return;\n";
                }
                emit_indent();
                out << "return;\n";
            } else {
                out << "gbrt_jump_hl(ctx);\n";
                if (options.emit_cycle_counting && group_cycles > 0) {
                    emit_indent();
                    out << "gb_tick(ctx, " << (int)group_cycles << ");\n";
                    emit_indent(); out << "if (ctx->stopped) return;\n";
                }
                emit_indent();
                out << "return;\n";
            }
            break;
            
        case ir::Opcode::JUMP_CC: {
            uint16_t target = instr.dst.value.imm16;
            uint8_t tbank = instr.dst.bank; // Use instr.dst.bank for target bank
            const char* cond = cond_names[instr.src.value.condition];
            const char* expr = (instr.src.value.condition == 0) ? "!ctx->f_z" :
                               (instr.src.value.condition == 1) ? "ctx->f_z" :
                               (instr.src.value.condition == 2) ? "!ctx->f_c" : "ctx->f_c";

            if (tbank == 255) {
                // Cross-bank or unknown, call dispatcher
                out << "if (" << expr << ") {\n";
                emit_indent(); out << "    ctx->pc = 0x" << std::hex << target << std::dec << ";\n";
                if (options.emit_cycle_counting) {
                    emit_indent(); out << "    gb_tick(ctx, " << (int)instr.cycles_branch_taken << ");\n";
                    emit_indent(); out << "    if (ctx->stopped) return;\n";
                }
                emit_indent(); out << "    return;\n";
                emit_indent(); out << "} /* " << cond << " */\n";
            } else {
                std::string target_func = program.make_function_name(tbank, target);
                bool func_exists = program.functions.find(target_func) != program.functions.end();

                if (func_exists && target_func == current_func_name) {
                    out << "if (" << expr << ") {\n";
                    emit_indent(); out << "    ctx->pc = 0x" << std::hex << target << std::dec << ";\n";
                    if (options.emit_cycle_counting) {
                        emit_indent(); out << "    gb_tick(ctx, " << (int)instr.cycles_branch_taken << ");\n";
                        emit_indent(); out << "    if (ctx->stopped) return;\n";
                    }
                    emit_indent(); out << "    goto loc_" << std::hex << std::setfill('0') 
                        << std::setw(4) << target << std::dec << ";\n";
                    emit_indent(); out << "} /* " << cond << " */\n";
                } else if (func_exists) {
                    // Different function: call and return
                    out << "if (" << expr << ") {\n";
                    emit_indent(); out << "    ctx->pc = 0x" << std::hex << target << std::dec << ";\n";
                    if (options.emit_cycle_counting) {
                        emit_indent(); out << "    gb_tick(ctx, " << (int)instr.cycles_branch_taken << ");\n";
                        emit_indent(); out << "    if (ctx->stopped) return;\n";
                    }
                    emit_indent(); out << "    " << target_func << "(ctx);\n";
                    emit_indent(); out << "    return;\n";
                    emit_indent(); out << "} /* " << cond << " */\n";
                } else {
                    // Fallback to dispatcher
                    out << "if (" << expr << ") {\n";
                    emit_indent(); out << "    ctx->pc = 0x" << std::hex << target << std::dec << ";\n";
                    if (options.emit_cycle_counting) {
                        emit_indent(); out << "    gb_tick(ctx, " << (int)instr.cycles_branch_taken << ");\n";
                        emit_indent(); out << "    if (ctx->stopped) return;\n";
                    }
                    emit_indent(); out << "    return;\n";
                    emit_indent(); out << "} /* " << cond << " */\n";
                }
            }
            // Branch NOT taken: update PC to next and tick with base cycles
            if (next_pc_val != 0) {
                emit_indent(); out << "ctx->pc = 0x" << std::hex << next_pc_val << std::dec << ";\n";
            }
            if (options.emit_cycle_counting && group_cycles > 0) {
                emit_indent(); out << "gb_tick(ctx, " << (int)group_cycles << ");\n";
                emit_indent(); out << "if (ctx->stopped) return;\n";
            }
            break;
        }
            
        case ir::Opcode::CALL: {
            uint16_t target = instr.dst.value.imm16;
            uint8_t target_bank = instr.dst.bank;
            uint16_t return_addr = instr.source_address + 3;

            if (target_bank == 255) {
                // Cross-bank or unknown, call dispatcher
                out << "gb_push16(ctx, 0x" << std::hex << return_addr << std::dec << ");\n";
                emit_indent(); out << "ctx->pc = 0x" << std::hex << target << std::dec << ";\n";
                if (options.emit_cycle_counting && group_cycles > 0) {
                    emit_indent(); out << "gb_tick(ctx, " << (int)group_cycles << ");\n";
                    emit_indent(); out << "if (ctx->stopped) return;\n";
                }
                emit_indent(); out << "return;\n";
            } else {
                std::string func_name = program.make_function_name(target_bank, target);
                bool func_exists = program.functions.find(func_name) != program.functions.end();

                out << "gb_push16(ctx, 0x" << std::hex << return_addr << std::dec << ");\n";
                emit_indent(); out << "ctx->pc = 0x" << std::hex << target << std::dec << ";\n";
                if (options.emit_cycle_counting && group_cycles > 0) {
                    emit_indent(); out << "gb_tick(ctx, " << (int)group_cycles << ");\n";
                    emit_indent(); out << "if (ctx->stopped) return;\n";
                }
                emit_indent();
                
                if (func_exists) {
                    out << func_name << "(ctx);\n";
                } else {
                    // Fallback to dispatcher (implicit by return)
                }
                emit_indent();
                out << "return;\n";
            }
            break;
        }

        case ir::Opcode::CALL_CC: {
            uint16_t target = instr.dst.value.imm16;
            uint8_t target_bank = instr.dst.bank;
            uint16_t return_addr = instr.source_address + 3;
            const char* cond = cond_names[instr.src.value.condition];
            const char* expr = (instr.src.value.condition == 0) ? "!ctx->f_z" :
                               (instr.src.value.condition == 1) ? "ctx->f_z" :
                               (instr.src.value.condition == 2) ? "!ctx->f_c" : "ctx->f_c";
            
            if (target_bank == 255) {
                out << "if (" << expr << ") {\n";
                emit_indent(); out << "    gb_push16(ctx, 0x" << std::hex << return_addr << std::dec << ");\n";
                emit_indent(); out << "    ctx->pc = 0x" << std::hex << target << std::dec << ";\n";
                if (options.emit_cycle_counting) {
                    emit_indent(); out << "    gb_tick(ctx, " << (int)instr.cycles_branch_taken << ");\n";
                    emit_indent(); out << "    if (ctx->stopped) return;\n";
                }
                emit_indent(); out << "    return;\n";
                emit_indent(); out << "} /* " << cond << " */\n";
            } else {
                std::string func_name = program.make_function_name(target_bank, target);
                bool func_exists = program.functions.find(func_name) != program.functions.end();

                out << "if (" << expr << ") {\n";
                emit_indent(); out << "    gb_push16(ctx, 0x" << std::hex << return_addr << std::dec << ");\n";
                emit_indent(); out << "    ctx->pc = 0x" << std::hex << target << std::dec << ";\n";
                if (options.emit_cycle_counting) {
                    emit_indent(); out << "    gb_tick(ctx, " << (int)instr.cycles_branch_taken << ");\n";
                    emit_indent(); out << "    if (ctx->stopped) return;\n";
                }
                if (func_exists) {
                    emit_indent(); out << "    " << func_name << "(ctx);\n";
                } else {
                    // Fallback to dispatcher (implicit by return)
                }
                emit_indent(); out << "    return;\n";
                emit_indent(); out << "} /* " << cond << " */\n";
            }
            
            // Branch NOT taken
            if (next_pc_val != 0) {
                emit_indent(); out << "ctx->pc = 0x" << std::hex << next_pc_val << std::dec << ";\n";
            }
            if (options.emit_cycle_counting && group_cycles > 0) {
                emit_indent(); out << "gb_tick(ctx, " << (int)group_cycles << ");\n";
                emit_indent(); out << "if (ctx->stopped) return;\n";
            }
            break;
        }
            
        case ir::Opcode::RET:
            out << "gb_ret(ctx);\n";
            if (options.emit_cycle_counting && group_cycles > 0) {
                emit_indent();
                out << "gb_tick(ctx, " << (int)group_cycles << ");\n";
            }
            emit_indent();
            out << "return;\n";
            break;
            
        case ir::Opcode::RET_CC: {
            const char* cond = cond_names[instr.src.value.condition];
            const char* expr = (instr.src.value.condition == 0) ? "!ctx->f_z" :
                               (instr.src.value.condition == 1) ? "ctx->f_z" :
                               (instr.src.value.condition == 2) ? "!ctx->f_c" : "ctx->f_c";
            out << "if (" << expr << ") {\n";
            emit_indent(); out << "    gb_ret(ctx);\n";
            if (options.emit_cycle_counting) {
                emit_indent(); out << "    gb_tick(ctx, 20); /* RET_CC cycles always 20 if taken */\n";
            }
            emit_indent(); out << "    return;\n";
            emit_indent(); out << "} /* " << cond << " */\n";
            // Not taken: update PC and tick
            if (next_pc_val != 0) {
                emit_indent(); out << "ctx->pc = 0x" << std::hex << next_pc_val << std::dec << ";\n";
            }
            if (options.emit_cycle_counting && group_cycles > 0) {
                emit_indent(); out << "gb_tick(ctx, " << (int)group_cycles << ");\n";
                emit_indent(); out << "if (ctx->stopped) return;\n";
            }
            break;
        }
            
        case ir::Opcode::RETI:
            out << "ctx->ime = 1;\n";
            emit_indent(); out << "gb_ret(ctx);\n";
            if (options.emit_cycle_counting && group_cycles > 0) {
                emit_indent(); out << "gb_tick(ctx, " << (int)group_cycles << ");\n";
            }
            emit_indent(); out << "return;\n";
            break;
            
        case ir::Opcode::RST:
            {
                // Push return address (instruction size 1)
                uint16_t next_pc = instr.source_address + 1;
                out << "gb_push16(ctx, 0x" << std::hex << next_pc << std::dec << ");\n";
                emit_indent();
                
                uint8_t vector = instr.dst.value.rst_vec;
                out << "ctx->pc = 0x" << std::hex << std::setfill('0') << std::setw(2) 
                    << (int)vector << std::dec << ";\n";
                
                if (options.emit_cycle_counting && group_cycles > 0) {
                    emit_indent(); out << "gb_tick(ctx, " << (int)group_cycles << ");\n";
                    emit_indent(); out << "if (ctx->stopped) return;\n";
                }
                
                emit_indent(); out << "/* Fallback to dispatcher */\n";
                emit_indent(); out << "return;\n";
                
                emit_indent();
                out << "return;\n";
            }
            break;
            
        case ir::Opcode::HALT:
            // HALT bug: If IME=0 and there's a pending interrupt, next PC increment fails
            out << "if (!ctx->ime && (gb_read8(ctx, 0xFFFF) & gb_read8(ctx, 0xFF0F) & 0x1F)) {\n";
            emit_indent(); out << "    ctx->halt_bug = 1;\n";
            if (next_pc_val != 0) {
                 emit_indent(); out << "    ctx->pc = 0x" << std::hex << next_pc_val << std::dec << ";\n";
            }
            emit_indent(); out << "    return; /* Force interpreter to handle bug */\n";
            emit_indent(); out << "} else {\n";
            emit_indent(); out << "    /* Update PC to next instruction so interrupt return address is correct */\n";
            if (next_pc_val != 0) {
                 emit_indent(); out << "    ctx->pc = 0x" << std::hex << next_pc_val << std::dec << ";\n";
            }
            emit_indent(); out << "    gb_halt(ctx);\n";
            emit_indent(); out << "    if (ctx->halted) return;\n";
            emit_indent(); out << "}\n";
            break;
            
        case ir::Opcode::STOP:
            out << "gb_stop(ctx);\n";
            break;
            
        case ir::Opcode::DI:
            out << "ctx->ime = 0; ctx->ime_pending = 0; /* Also cancel pending EI */\n";
            break;
            
        case ir::Opcode::EI:
            out << "ctx->ime_pending = 1;\n";
            break;
            
        case ir::Opcode::DAA:
            out << "gb_daa(ctx);\n";
            break;
            
        case ir::Opcode::CPL:
            out << "ctx->a = ~ctx->a; ctx->f_n = 1; ctx->f_h = 1;\n";
            break;
            
        case ir::Opcode::SCF:
            out << "ctx->f_n = 0; ctx->f_h = 0; ctx->f_c = 1;\n";
            break;
            
        case ir::Opcode::CCF:
            out << "ctx->f_n = 0; ctx->f_h = 0; ctx->f_c = !ctx->f_c;\n";
            break;
            
        case ir::Opcode::BIT:
            if (instr.dst.value.reg8 == 6) {
                // BIT n,(HL) - read from memory
                out << "gb_bit(ctx, " << (int)instr.src.value.bit_idx 
                    << ", gb_read8(ctx, ctx->hl));\n";
            } else {
                out << "gb_bit(ctx, " << (int)instr.src.value.bit_idx 
                    << ", ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::SET:
            if (instr.dst.value.reg8 == 6) {
                // SET n,(HL) - read-modify-write memory
                out << "gb_write8(ctx, ctx->hl, gb_read8(ctx, ctx->hl) | (1 << " 
                    << (int)instr.src.value.bit_idx << "));\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " |= (1 << " << (int)instr.src.value.bit_idx << ");\n";
            }
            break;
            
        case ir::Opcode::RES:
            if (instr.dst.value.reg8 == 6) {
                // RES n,(HL) - read-modify-write memory
                out << "gb_write8(ctx, ctx->hl, gb_read8(ctx, ctx->hl) & ~(1 << " 
                    << (int)instr.src.value.bit_idx << "));\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " &= ~(1 << " << (int)instr.src.value.bit_idx << ");\n";
            }
            break;
        
        // === I/O Port Operations ===
        case ir::Opcode::IO_READ:
            // LDH A,(n) - read from 0xFF00 + immediate offset
            out << "ctx->a = gb_read8(ctx, 0xFF00 + 0x" << std::hex << std::setfill('0') 
                << std::setw(2) << (int)instr.src.value.imm8 << std::dec << ");\n";
            break;
            
        case ir::Opcode::IO_READ_C:
            // LDH A,(C) - read from 0xFF00 + C register
            out << "ctx->a = gb_read8(ctx, 0xFF00 + ctx->c);\n";
            break;
            
        case ir::Opcode::IO_WRITE:
            // LDH (n),A - write to 0xFF00 + immediate offset
            out << "gb_write8(ctx, 0xFF00 + 0x" << std::hex << std::setfill('0') 
                << std::setw(2) << (int)instr.dst.value.imm8 << std::dec << ", ctx->a);\n";
            break;
            
        case ir::Opcode::IO_WRITE_C:
            // LDH (C),A - write to 0xFF00 + C register
            out << "gb_write8(ctx, 0xFF00 + ctx->c, ctx->a);\n";
            break;
            
        // === Rotate/Shift Operations ===
        case ir::Opcode::RLC:
            if (instr.dst.value.reg8 == 6) {
                // RLC (HL) - read, rotate, write back
                out << "gb_write8(ctx, ctx->hl, gb_rlc(ctx, gb_read8(ctx, ctx->hl)));\n";
            } else if (instr.extra.type == ir::OperandType::IMM8 && instr.extra.value.imm8 == 1) {
                // RLCA variant (Z flag always 0)
                out << "gb_rlca(ctx);\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " = gb_rlc(ctx, ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::RRC:
            if (instr.dst.value.reg8 == 6) {
                out << "gb_write8(ctx, ctx->hl, gb_rrc(ctx, gb_read8(ctx, ctx->hl)));\n";
            } else if (instr.extra.type == ir::OperandType::IMM8 && instr.extra.value.imm8 == 1) {
                out << "gb_rrca(ctx);\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " = gb_rrc(ctx, ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::RL:
            if (instr.dst.value.reg8 == 6) {
                out << "gb_write8(ctx, ctx->hl, gb_rl(ctx, gb_read8(ctx, ctx->hl)));\n";
            } else if (instr.extra.type == ir::OperandType::IMM8 && instr.extra.value.imm8 == 1) {
                out << "gb_rla(ctx);\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " = gb_rl(ctx, ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::RR:
            if (instr.dst.value.reg8 == 6) {
                out << "gb_write8(ctx, ctx->hl, gb_rr(ctx, gb_read8(ctx, ctx->hl)));\n";
            } else if (instr.extra.type == ir::OperandType::IMM8 && instr.extra.value.imm8 == 1) {
                out << "gb_rra(ctx);\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " = gb_rr(ctx, ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::SLA:
            if (instr.dst.value.reg8 == 6) {
                out << "gb_write8(ctx, ctx->hl, gb_sla(ctx, gb_read8(ctx, ctx->hl)));\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " = gb_sla(ctx, ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::SRA:
            if (instr.dst.value.reg8 == 6) {
                out << "gb_write8(ctx, ctx->hl, gb_sra(ctx, gb_read8(ctx, ctx->hl)));\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " = gb_sra(ctx, ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::SRL:
            if (instr.dst.value.reg8 == 6) {
                out << "gb_write8(ctx, ctx->hl, gb_srl(ctx, gb_read8(ctx, ctx->hl)));\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " = gb_srl(ctx, ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::SWAP:
            if (instr.dst.value.reg8 == 6) {
                out << "gb_write8(ctx, ctx->hl, gb_swap(ctx, gb_read8(ctx, ctx->hl)));\n";
            } else {
                out << "ctx->" << reg8_names[instr.dst.value.reg8] 
                    << " = gb_swap(ctx, ctx->" << reg8_names[instr.dst.value.reg8] << ");\n";
            }
            break;
            
        case ir::Opcode::MOV_REG_REG16:
            // LD SP,HL - copy 16-bit register to 16-bit register
            out << "ctx->" << reg16_names[instr.dst.value.reg16] 
                << " = ctx->" << reg16_names[instr.src.value.reg16] << ";\n";
            break;
            
        case ir::Opcode::LD_HL_SP_N:
            out << "gb_ld_hl_sp_n(ctx, " << (int)instr.src.value.offset << ");\n";
            break;
            
        case ir::Opcode::STORE16:
            // LD (nn),SP - store 16-bit register to memory
            out << "gb_write16(ctx, 0x" << std::hex << std::setfill('0') 
                << std::setw(4) << instr.dst.value.imm16 << std::dec 
                << ", ctx->" << reg16_names[instr.src.value.reg16] << ");\n";
            break;
            
        default:
            out << "/* Unhandled opcode */\n";
            break;
    }
    
    // Emit cycle counting and PPU tick
    bool is_control_flow = (instr.opcode == ir::Opcode::RET || 
                            instr.opcode == ir::Opcode::RETI ||
                            instr.opcode == ir::Opcode::RET_CC ||
                            instr.opcode == ir::Opcode::JUMP ||
                            instr.opcode == ir::Opcode::JUMP_CC ||
                            instr.opcode == ir::Opcode::JUMP_REG ||
                            instr.opcode == ir::Opcode::JR ||
                            instr.opcode == ir::Opcode::JR_CC ||
                            instr.opcode == ir::Opcode::CALL ||
                            instr.opcode == ir::Opcode::CALL_CC ||
                            instr.opcode == ir::Opcode::RST ||
                            instr.opcode == ir::Opcode::HALT ||
                            instr.opcode == ir::Opcode::STOP);

    if (is_last_in_group && !is_control_flow) {
        // Update PC for correct resumption if stopped
        if (next_pc_val != 0) {
            emit_indent();
            out << "ctx->pc = 0x" << std::hex << next_pc_val << std::dec << ";\n";
        }
        
        if (options.emit_cycle_counting && group_cycles > 0) {
            emit_indent();
            out << "gb_tick(ctx, " << (int)group_cycles << ");\n";
            emit_indent();
            out << "if (ctx->stopped) return;\n";
        }
    }
}

GeneratedOutput generate_output(const ir::Program& program,
                                const uint8_t* rom_data,
                                size_t rom_size,
                                const GeneratorOptions& options) {
    GeneratedOutput output;
    
    // Generate header
    std::ostringstream header_ss;
    header_ss << "/* Generated by gbrecomp */\n";
    header_ss << "#ifndef " << options.output_prefix << "_H\n";
    header_ss << "#define " << options.output_prefix << "_H\n\n";
    header_ss << "#include \"gbrt.h\"\n\n";
    header_ss << "void " << options.output_prefix << "_run(GBContext* ctx);\n";
    header_ss << "void " << options.output_prefix << "_init(GBContext* ctx);\n\n";
    header_ss << "#endif\n";
    output.header_content = header_ss.str();
    output.header_file = options.output_prefix + ".h";
    
    // Generate source
    std::ostringstream source_ss;
    source_ss << "/* Generated by gbrecomp from " << program.rom_name << " */\n";
    source_ss << "#include \"" << options.output_prefix << ".h\"\n";
    source_ss << "#include \"gbrt.h\"\n";
    source_ss << "#include <stdio.h>\n";
    source_ss << "#include <stdlib.h>\n\n";
    
    // Forward declarations
    source_ss << "/* Forward declarations */\n";
    for (const auto& [name, func] : program.functions) {
        source_ss << "static void " << func.name << "(GBContext* ctx);\n";
    }
    source_ss << "\n";
    
    // Generate dispatch function for banked calls
    source_ss << "/* Bank dispatch - routes calls to the correct bank function */\n";
    source_ss << "void gb_dispatch(GBContext* ctx, uint16_t addr) {\n";
    source_ss << "    ctx->pc = addr;\n";
    source_ss << "    while (!ctx->stopped && !ctx->halted) {\n";
    source_ss << "        addr = ctx->pc;\n";
    source_ss << "        uint8_t bank = ctx->rom_bank;\n";
    source_ss << "        if (addr < 0x4000) bank = 0;\n";
        
    /* Debug checks in dispatch loop */
    source_ss << "        if (gbrt_instruction_limit > 0 && gbrt_instruction_count >= gbrt_instruction_limit) {\n";
    source_ss << "            fprintf(stderr, \"[LIMIT] Reached instruction limit %llu\\n\", (unsigned long long)gbrt_instruction_limit);\n";
    source_ss << "            exit(0);\n";
    source_ss << "        }\n";
    source_ss << "        gbrt_instruction_count++;\n";
    source_ss << "        \n";
    source_ss << "        if (gbrt_trace_enabled) {\n";
    source_ss << "            fprintf(stderr, \"[TRACE] Dispatch 0x%04X (Bank %d)\\n\", addr, bank);\n";
    source_ss << "        }\n";

    source_ss << "        switch (addr) {\n";
    
    // Group functions by address for the switch statement
    // Map every basic block start address to its function
    struct DispatchEntry {
        uint8_t bank;
        std::string name;
        bool is_entry;
        bool operator<(const DispatchEntry& o) const {
            if (bank != o.bank) return bank < o.bank;
            if (is_entry != o.is_entry) return is_entry > o.is_entry; // true (entry) first
            return name < o.name;
        }
        bool operator==(const DispatchEntry& o) const {
            return bank == o.bank && is_entry == o.is_entry; // Treat same bank/entry-status as equal for unique? NO.
            // We want exact match for std::unique first.
            // But wait, my manual unique below handles bank collisions.
            return bank == o.bank && name == o.name && is_entry == o.is_entry;
        }
    };
    std::map<uint16_t, std::vector<DispatchEntry>> addr_to_funcs;

    for (const auto& [name, func] : program.functions) {
        addr_to_funcs[func.entry_address].push_back({func.bank, func.name, true});
        for (uint32_t block_id : func.block_ids) {
            auto it = program.blocks.find(block_id);
            if (it != program.blocks.end()) {
                uint16_t addr = it->second.start_address;
                if (addr != func.entry_address) {
                    addr_to_funcs[addr].push_back({func.bank, func.name, false});
                }
            }
        }
    }
    
    for (auto& [addr, funcs] : addr_to_funcs) {
        std::sort(funcs.begin(), funcs.end());
        funcs.erase(std::unique(funcs.begin(), funcs.end()), funcs.end());
        
        // Remove bank collisions (prefer entry)
        auto last = std::unique(funcs.begin(), funcs.end(), [](const DispatchEntry& a, const DispatchEntry& b){
            return a.bank == b.bank;
        });
        funcs.erase(last, funcs.end());

        source_ss << "            case 0x" << std::hex << std::setfill('0') << std::setw(4) << addr << std::dec << ":\n";
        // Check if bank validation is required (allocatable space >= 0x4000)
        bool validation_needed = (addr >= 0x4000);
        
        if (funcs.size() == 1 && !validation_needed) {
            source_ss << "                " << funcs[0].name << "(ctx); break;\n";
        } else {
            source_ss << "                switch (bank) {\n";
            for (const auto& entry : funcs) {
                source_ss << "                    case " << (int)entry.bank << ": " << entry.name << "(ctx); break;\n";
            }
            source_ss << "                    default: gb_interpret(ctx, addr); break;\n";
            source_ss << "                }\n";
            source_ss << "                break;\n";
        }
    }
    source_ss << "            default: gb_interpret(ctx, addr); break;\n";
    source_ss << "        }\n";
    source_ss << "    }\n";
    source_ss << "}\n\n";
    
    source_ss << "void gb_dispatch_call(GBContext* ctx, uint16_t addr) {\n";
    source_ss << "    gb_dispatch(ctx, addr);\n";
    source_ss << "}\n\n";
    
    // Emit each function with real IR code
    for (const auto& [name, func] : program.functions) {
        source_ss << "/* Function at ";
        if (func.bank > 0) {
            source_ss << std::hex << std::setfill('0') << std::setw(2) << (int)func.bank << ":";
        }
        source_ss << std::hex << std::setfill('0') << std::setw(4) << func.entry_address << std::dec << " */\n";
        source_ss << "static void " << func.name << "(GBContext* ctx) {\n";
        
        // Sort block_ids by their start address to ensure proper fallthrough order
        std::vector<uint32_t> sorted_block_ids = func.block_ids;
        std::sort(sorted_block_ids.begin(), sorted_block_ids.end(), 
            [&program](uint32_t a, uint32_t b) {
                auto it_a = program.blocks.find(a);
                auto it_b = program.blocks.find(b);
                if (it_a == program.blocks.end()) return false;
                if (it_b == program.blocks.end()) return true;
                return it_a->second.start_address < it_b->second.start_address;
            });
            
        // Emit computed goto for entry into the correct block
        source_ss << "    switch (ctx->pc) {\n";
        for (uint32_t block_id : sorted_block_ids) {
            auto it = program.blocks.find(block_id);
            if (it != program.blocks.end()) {
                source_ss << "        case 0x" << std::hex << std::setfill('0') << std::setw(4) 
                          << it->second.start_address << std::dec << ": goto loc_" 
                          << std::hex << std::setfill('0') << std::setw(4) 
                          << it->second.start_address << std::dec << ";\n";
            }
        }
        source_ss << "        default: break;\n";
        source_ss << "    }\n\n";
        
        // Emit each block in this function (now sorted by address)
        for (size_t block_idx = 0; block_idx < sorted_block_ids.size(); block_idx++) {
            uint32_t block_id = sorted_block_ids[block_idx];
            auto block_it = program.blocks.find(block_id);
            if (block_it == program.blocks.end()) continue;
            const ir::BasicBlock& block = block_it->second;
            
            // Generate label from block address
            source_ss << "loc_" << std::hex << std::setfill('0') << std::setw(4) 
                      << block.start_address << std::dec << ":\n";
            
            // Emit each IR instruction, grouped by source address
            uint32_t group_cycles = 0;
            for (size_t i = 0; i < block.instructions.size(); ++i) {
                const auto& ir_instr = block.instructions[i];
                group_cycles += ir_instr.cycles;
                
                uint16_t next_pc = 0;
                bool is_last_in_group = true;
                
                // Identify if this is the last IR instruction for this GameBoy instruction
                if (i + 1 < block.instructions.size()) {
                    if (block.instructions[i+1].source_address == ir_instr.source_address && ir_instr.source_address != 0) {
                        is_last_in_group = false;
                        next_pc = ir_instr.source_address;
                    } else {
                        next_pc = block.instructions[i+1].source_address;
                    }
                } else {
                    next_pc = block.end_address;
                }
                
                // If it's the last in group, we use the accumulated cycles
                // Actually, let's just use ir_instr.cycles if we don't want to refactor cycles accumulation yet.
                // Re-think: better to pass the accumulated cycles only at the end.
                
                uint32_t cycles_to_pass = is_last_in_group ? group_cycles : 0;
                if (is_last_in_group) group_cycles = 0; // Reset for next group
                
                emit_ir_instruction(source_ss, ir_instr, program, 1, options, next_pc, cycles_to_pass, is_last_in_group, func.name);
            }
            
            // Check if block falls through
            bool falls_through = true;
            uint16_t fallthrough_addr = block.end_address;
            
            // Find the last non-NOP instruction
            for (auto it = block.instructions.rbegin(); it != block.instructions.rend(); ++it) {
                if (it->opcode == ir::Opcode::NOP) continue;
                
                // Unconditional terminators do not fall through
                if (it->opcode == ir::Opcode::JUMP || 
                    it->opcode == ir::Opcode::RET) {
                    falls_through = false;
                }
                break;
            }
            
            bool next_is_fallthrough = false;
            if (block_idx + 1 < sorted_block_ids.size()) {
                uint32_t next_id = sorted_block_ids[block_idx + 1];
                auto next_it = program.blocks.find(next_id);
                if (next_it != program.blocks.end()) {
                    if (next_it->second.start_address == fallthrough_addr) {
                        next_is_fallthrough = true;
                    }
                }
            }
            
            if (falls_through && !next_is_fallthrough) {
                    // Debug specific function 27eb
                    if (func.name == "func_27eb") {
                        std::cerr << "DEBUG: found func_27eb falling through to 0x" << std::hex << fallthrough_addr << std::dec << "\n";
                    }

                    // Check if fallthrough target exists as a block in this function
                    bool fallthrough_exists_in_function = false;
                    for (uint32_t fn_block_id : sorted_block_ids) {
                        auto fn_block_it = program.blocks.find(fn_block_id);
                        if (fn_block_it != program.blocks.end() && 
                            fn_block_it->second.start_address == fallthrough_addr) {
                            fallthrough_exists_in_function = true;
                            break;
                        }
                    }
                    
                    // Only emit goto if the target block exists in this function
                    if (fallthrough_exists_in_function) {
                        // Emit explicit goto to fallthrough block
                        source_ss << "    goto loc_" << std::hex << std::setfill('0') 
                                  << std::setw(4) << fallthrough_addr << std::dec 
                                  << "; /* fallthrough */\n";
                    } else {
                        if (func.name == "func_27eb") {
                             std::cerr << "DEBUG: func_27eb fallthrough not in function. Searching targets...\n";
                        }
                        // Fallthrough to another function?
                        // Check if any function starts at fallthrough_addr in the same bank
                        bool found_target_func = false;
                        for (const auto& kv : program.functions) {
                            const ir::Function& target_func = kv.second;
                            if (target_func.bank == func.bank && target_func.entry_address == fallthrough_addr) {
                                source_ss << "    /* fallthrough to function */\n";
                                source_ss << "    " << target_func.name << "(ctx);\n";
                                source_ss << "    return;\n";
                                found_target_func = true;
                                if (func.name == "func_27eb") std::cerr << "DEBUG: Found target: " << target_func.name << "\n";
                                break;
                            }
                        }
                        
                        if (!found_target_func) {
                            if (func.name == "func_27eb") std::cerr << "DEBUG: No target function found for 0x" << std::hex << fallthrough_addr << std::dec << "\n";
                            source_ss << "    /* warning: fallthrough to unanalyzed code at 0x" 
                                      << std::hex << fallthrough_addr << std::dec << " in bank " << (int)func.bank << " */\n";
                            
                            source_ss << "    return;\n";
                        }
                    }

            }
        }
        
        // If function is empty or has no terminator, add a return
        source_ss << "}\n\n";
    }
    
    // Extern reference to ROM data
    source_ss << "/* Extern reference to ROM data */\n";
    source_ss << "extern const uint8_t rom_data[];\n\n";
    
    // Emit init and run functions
    source_ss << "void " << options.output_prefix << "_init(GBContext* ctx) {\n";
    source_ss << "    /* Load ROM data into context */\n";
    source_ss << "    gb_context_load_rom(ctx, rom_data, " << rom_size << ");\n";
    source_ss << "    /* Set MBC type from header */\n";
    source_ss << "    ctx->mbc_type = rom_data[0x147];\n";
    source_ss << "}\n\n";
    
    source_ss << "void " << options.output_prefix << "_run(GBContext* ctx) {\n";
    source_ss << "    // Start the trampoline loop - execution will stay here until stopped\n";
    source_ss << "    gb_dispatch(ctx, ctx->pc);\n";
    source_ss << "}\n";
    
    output.source_content = source_ss.str();
    output.source_file = options.output_prefix + ".c";
    
    // Generate ROM data
    std::ostringstream rom_ss;
    rom_ss << "/* ROM data */\n";
    rom_ss << "#include <stdint.h>\n";
    rom_ss << "#include <stddef.h>\n\n";
    rom_ss << "const uint8_t rom_data[" << rom_size << "] = {\n";
    for (size_t i = 0; i < rom_size; i++) {
        if (i % 16 == 0) rom_ss << "    ";
        rom_ss << "0x" << std::hex << std::setfill('0') << std::setw(2) 
               << (int)rom_data[i];
        if (i < rom_size - 1) rom_ss << ",";
        if (i % 16 == 15 || i == rom_size - 1) rom_ss << "\n";
        else rom_ss << " ";
    }
    rom_ss << std::dec << "};\n";
    rom_ss << "const size_t rom_size = " << rom_size << ";\n";
    output.rom_data_content = rom_ss.str();
    output.rom_data_file = options.output_prefix + "_rom.c";
    
    // Generate main
    std::ostringstream main_ss;
    main_ss << "/* Main entry point */\n";
    main_ss << "#include \"" << options.output_prefix << ".h\"\n";
    main_ss << "#include \"gbrt.h\"\n";
    main_ss << "#ifdef GB_HAS_SDL2\n";
    main_ss << "#include \"platform_sdl.h\"\n";
    main_ss << "#endif\n";
    main_ss << "#include <stdio.h>\n";
    main_ss << "#include <stdio.h>\n";
    main_ss << "#include <stdlib.h>\n";
    main_ss << "#include <string.h>\n\n";
    main_ss << "int main(int argc, char* argv[]) {\n";
    main_ss << "    // Parse args\n";
    main_ss << "    for (int i = 1; i < argc; i++) {\n";
    main_ss << "        if (strcmp(argv[i], \"--trace\") == 0) {\n";
    main_ss << "            gbrt_trace_enabled = true;\n";
    main_ss << "            printf(\"Trace enabled\\n\");\n";
    main_ss << "        } else if (strcmp(argv[i], \"--limit\") == 0 && i + 1 < argc) {\n";
    main_ss << "            gbrt_instruction_limit = strtoull(argv[++i], NULL, 10);\n";
    main_ss << "            printf(\"Instruction limit: %llu\\n\", (unsigned long long)gbrt_instruction_limit);\n";
    main_ss << "        } else if (strcmp(argv[i], \"--input\") == 0 && i + 1 < argc) {\n";
    main_ss << "            gb_platform_set_input_script(argv[++i]);\n";
    main_ss << "        } else if (strcmp(argv[i], \"--dump-frames\") == 0 && i + 1 < argc) {\n";
    main_ss << "            gb_platform_set_dump_frames(argv[++i]);\n";
    main_ss << "        } else if (strcmp(argv[i], \"--screenshot-prefix\") == 0 && i + 1 < argc) {\n";
    main_ss << "            gb_platform_set_screenshot_prefix(argv[++i]);\n";
    main_ss << "        }\n";
    main_ss << "    }\n\n";
    main_ss << "    GBContext* ctx = gb_context_create(NULL);\n";
    main_ss << "    if (!ctx) {\n";
    main_ss << "        fprintf(stderr, \"Failed to create context\\n\");\n";
    main_ss << "        return 1;\n";
    main_ss << "    }\n";
    main_ss << "    " << options.output_prefix << "_init(ctx);\n";
    main_ss << "\n";
    main_ss << "#ifdef GB_HAS_SDL2\n";
    main_ss << "    // Initialize SDL2 platform with 3x scaling\n";
    main_ss << "    if (!gb_platform_init(3)) {\n";
    main_ss << "        fprintf(stderr, \"Failed to initialize platform\\n\");\n";
    main_ss << "        gb_context_destroy(ctx);\n";
    main_ss << "        return 1;\n";
    main_ss << "    }\n";
    main_ss << "    gb_platform_register_context(ctx);\n";
    main_ss << "\n";
    main_ss << "    // Run the game loop\n";
    main_ss << "    while (1) {\n";
    main_ss << "        gb_run_frame(ctx);\n";
    main_ss << "        if (!gb_platform_poll_events(ctx)) break;\n";
    main_ss << "        if (ctx->frame_done) {\n";
    main_ss << "            const uint32_t* fb = gb_get_framebuffer(ctx);\n";
    main_ss << "            if (fb) gb_platform_render_frame(fb);\n";
    main_ss << "            gb_reset_frame(ctx);\n";
    main_ss << "            ctx->stopped = 0;\n";
    main_ss << "            gb_platform_vsync();\n";
    main_ss << "        }\n";
    main_ss << "    }\n";
    main_ss << "    gb_platform_shutdown();\n";
    main_ss << "#else\n";
    main_ss << "    // No SDL2 - just run for testing\n";
    main_ss << "    " << options.output_prefix << "_run(ctx);\n";
    main_ss << "    printf(\"Recompiled code executed successfully!\\n\");\n";
    main_ss << "    printf(\"Registers: A=%02X B=%02X C=%02X\\n\", ctx->a, ctx->b, ctx->c);\n";
    main_ss << "#endif\n";
    main_ss << "\n";
    main_ss << "    gb_context_destroy(ctx);\n";
    main_ss << "    return 0;\n";
    main_ss << "}\n";
    output.main_content = main_ss.str();
    output.main_file = options.output_prefix + "_main.c";
    
    // Generate CMakeLists.txt
    std::ostringstream cmake_ss;
    cmake_ss << "cmake_minimum_required(VERSION 3.16)\n";
    cmake_ss << "project(" << options.output_prefix << " C)\n\n";
    cmake_ss << "# Set C standard\n";
    cmake_ss << "set(CMAKE_C_STANDARD 11)\n";
    cmake_ss << "set(CMAKE_C_STANDARD_REQUIRED ON)\n\n";
    // Calculate relative path to runtime
    namespace fs = std::filesystem;
    fs::path out_path(options.output_dir);
    std::string runtime_path;
    
    // Count depth to generate correct number of ../
    int depth = 0;
    for (const auto& p : out_path) {
        if (p == ".") continue;
        depth++;
    }
    // Ensure at least one level up
    if (depth == 0) depth = 1;

    std::stringstream rt_ss;
    for(int i=0; i<depth; i++) rt_ss << "../";
    rt_ss << "runtime";
    runtime_path = rt_ss.str();

    cmake_ss << "# Runtime library path (relative to this output directory)\n";
    cmake_ss << "set(GBRT_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/" << runtime_path << "\")\n\n";
    cmake_ss << "# Find SDL2\n";
    cmake_ss << "find_package(SDL2 REQUIRED)\n\n";
    cmake_ss << "# Create runtime library with PPU and platform support\n";
    cmake_ss << "add_library(gbrt STATIC\n";
    cmake_ss << "    ${GBRT_DIR}/src/gbrt.c\n";
    cmake_ss << "    ${GBRT_DIR}/src/ppu.c\n";
    cmake_ss << "    ${GBRT_DIR}/src/audio.c\n";
    cmake_ss << "    ${GBRT_DIR}/src/interpreter.c\n";
    cmake_ss << "    ${GBRT_DIR}/src/platform_sdl.c\n";
    cmake_ss << ")\n";
    cmake_ss << "target_include_directories(gbrt PUBLIC ${GBRT_DIR}/include)\n";
    cmake_ss << "target_link_libraries(gbrt PUBLIC SDL2::SDL2)\n";
    cmake_ss << "target_compile_definitions(gbrt PUBLIC GB_HAS_SDL2)\n\n";
    cmake_ss << "# Main executable\n";
    cmake_ss << "add_executable(" << options.output_prefix << "\n";
    cmake_ss << "    " << options.output_prefix << "_main.c\n";
    cmake_ss << "    " << options.output_prefix << ".c\n";
    cmake_ss << "    " << options.output_prefix << "_rom.c\n";
    cmake_ss << ")\n\n";
    cmake_ss << "target_link_libraries(" << options.output_prefix << " gbrt)\n";
    output.cmake_content = cmake_ss.str();
    output.cmake_file = "CMakeLists.txt";
    
    return output;
}

bool write_output(const GeneratedOutput& output, const std::string& output_dir) {
    namespace fs = std::filesystem;
    
    try {
        // Create output directory if it doesn't exist
        fs::path out_path(output_dir);
        if (!fs::exists(out_path)) {
            fs::create_directories(out_path);
        }
        
        // Write header file
        std::ofstream header_file(out_path / output.header_file);
        if (!header_file) return false;
        header_file << output.header_content;
        header_file.close();
        
        // Write source file
        std::ofstream source_file(out_path / output.source_file);
        if (!source_file) return false;
        source_file << output.source_content;
        source_file.close();
        
        // Write ROM data file
        std::ofstream rom_file(out_path / output.rom_data_file);
        if (!rom_file) return false;
        rom_file << output.rom_data_content;
        rom_file.close();
        
        // Write main file
        std::ofstream main_file(out_path / output.main_file);
        if (!main_file) return false;
        main_file << output.main_content;
        main_file.close();
        
        // Write CMakeLists.txt
        std::ofstream cmake_file(out_path / output.cmake_file);
        if (!cmake_file) return false;
        cmake_file << output.cmake_content;
        cmake_file.close();
        
        return true;
    } catch (...) {
        return false;
    }
}

} // namespace codegen
} // namespace gbrecomp
